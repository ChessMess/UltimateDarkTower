{
  "version": 3,
  "sources": ["../../../src/udtConstants.ts", "../../../src/udtTowerState.ts", "../../../src/UltimateDarkTower.ts", "../../../src/udtHelpers.ts", "../../../src/udtLogger.ts", "../../../src/udtBleConnection.ts", "../../../src/udtTowerResponse.ts", "../../../src/udtCommandFactory.ts", "../../../src/udtTowerCommands.ts", "../../../src/udtCommandQueue.ts", "../../../src/index.ts", "../../../examples/controller/TowerController.ts"],
  "sourcesContent": ["\n// Nordic Semicondutor's UART/Serial IDs for Bluetooth LE\nexport const UART_SERVICE_UUID = \"6e400001-b5a3-f393-e0a9-e50e24dcca9e\";\nexport const UART_TX_CHARACTERISTIC_UUID = \"6e400002-b5a3-f393-e0a9-e50e24dcca9e\";\nexport const UART_RX_CHARACTERISTIC_UUID = \"6e400003-b5a3-f393-e0a9-e50e24dcca9e\";\nexport const TOWER_DEVICE_NAME = \"ReturnToDarkTower\";\n\n// Device Information Service (DIS) UUIDs\nexport const DIS_SERVICE_UUID = \"0000180a-0000-1000-8000-00805f9b34fb\";\nexport const DIS_MANUFACTURER_NAME_UUID = \"00002a29-0000-1000-8000-00805f9b34fb\";\nexport const DIS_MODEL_NUMBER_UUID = \"00002a24-0000-1000-8000-00805f9b34fb\";\nexport const DIS_SERIAL_NUMBER_UUID = \"00002a25-0000-1000-8000-00805f9b34fb\";\nexport const DIS_HARDWARE_REVISION_UUID = \"00002a27-0000-1000-8000-00805f9b34fb\";\nexport const DIS_FIRMWARE_REVISION_UUID = \"00002a26-0000-1000-8000-00805f9b34fb\";\nexport const DIS_SOFTWARE_REVISION_UUID = \"00002a28-0000-1000-8000-00805f9b34fb\";\nexport const DIS_SYSTEM_ID_UUID = \"00002a23-0000-1000-8000-00805f9b34fb\";\nexport const DIS_IEEE_REGULATORY_UUID = \"00002a2a-0000-1000-8000-00805f9b34fb\";\nexport const DIS_PNP_ID_UUID = \"00002a50-0000-1000-8000-00805f9b34fb\";\nexport type CommandPacket = Uint8Array;\n\n// Tower command packet structure constants\nexport const TOWER_COMMAND_PACKET_SIZE = 20;\nexport const TOWER_STATE_DATA_SIZE = 19;\nexport const TOWER_COMMAND_HEADER_SIZE = 1;\nexport const TOWER_STATE_RESPONSE_MIN_LENGTH = 20;\nexport const TOWER_STATE_DATA_OFFSET = 1;\nexport const TOWER_COMMAND_TYPE_TOWER_STATE = 0x00;\n\n// Connection and monitoring constants\nexport const DEFAULT_CONNECTION_MONITORING_FREQUENCY = 2000; // milliseconds\nexport const DEFAULT_CONNECTION_MONITORING_TIMEOUT = 30000; // milliseconds\nexport const DEFAULT_BATTERY_HEARTBEAT_TIMEOUT = 3000; // milliseconds\nexport const BATTERY_STATUS_FREQUENCY = 200; // Tower sends battery status every ~200ms\n\n// Default retry settings\nexport const DEFAULT_RETRY_SEND_COMMAND_MAX = 5;\n\n// Tower geometry constants\nexport const TOWER_SIDES_COUNT = 4; // north, east, south, west\n\n// tower commands \nexport const TOWER_COMMANDS = {\n  towerState: 0, // not a sendable command\n  doorReset: 1,\n  unjamDrums: 2,\n  resetCounter: 3,\n  calibration: 4,\n  overwriteDrumStates: 5,\n  // go no further!\n};\n\n// tower commands enum\nexport const TC = {\n  STATE: \"TOWER_STATE\",\n  INVALID_STATE: \"INVALID_STATE\",\n  FAILURE: \"HARDWARE_FAILURE\",\n  JIGGLE: \"MECH_JIGGLE_TRIGGERED\",\n  UNEXPECTED: \"MECH_UNEXPECTED_TRIGGER\",\n  DURATION: \"MECH_DURATION\",\n  DIFFERENTIAL: \"DIFFERENTIAL_READINGS\",\n  CALIBRATION: \"CALIBRATION_FINISHED\",\n  BATTERY: \"BATTERY_READING\",\n}\n\nexport const DRUM_PACKETS = {\n  topMiddle: 1,\n  bottom: 2,\n}\n\n\nexport type Glyphs = \"cleanse\" | \"quest\" | \"battle\" | \"banner\" | \"reinforce\";\n\n// positions based on calibrated drum orientation\nexport const GLYPHS = {\n  cleanse: { name: \"Cleanse\", level: \"top\", side: \"north\" },\n  quest: { name: \"Quest\", level: \"top\", side: \"south\" },\n  battle: { name: \"Battle\", level: \"middle\", side: \"north\" },\n  banner: { name: \"Banner\", level: \"bottom\", side: \"north\" },\n  reinforce: { name: \"Reinforce\", level: \"bottom\", side: \"south\" },\n}\n\nexport const AUDIO_COMMAND_POS = 15;\nexport const SKULL_DROP_COUNT_POS = 17;\n\nexport type TowerLevels = \"top\" | \"middle\" | \"bottom\";\nexport type TowerSide = \"north\" | \"south\" | \"east\" | \"west\";\nexport type TowerCorner = \"northeast\" | \"southeast\" | \"southwest\" | \"northwest\";\n\nexport type SealIdentifier = {\n  side: TowerSide;\n  level: TowerLevels;\n};\n\nexport type LightTypes = \"base\" | \"doorway\" | \"ledge\";\n\nexport type DoorwayLight = { position: TowerSide, level: TowerLevels, style: string };\n\nexport type LedgeLight = { position: TowerCorner, style: string };\n\nexport type BaseLightLevel = \"top\" | \"bottom\" | \"a\" | \"b\";\nexport type BaseLightPosition = { side: TowerSide, level: BaseLightLevel };\nexport type BaseLightCornerPosition = { side: TowerCorner, level: BaseLightLevel };\nexport type BaseLight = { position: BaseLightPosition, style: string };\nexport type BaseLightCorner = { position: BaseLightCornerPosition, style: string };\n\nexport type Lights = {\n  doorway?: Array<DoorwayLight>,\n  ledge?: Array<LedgeLight>,\n  base?: Array<BaseLight>\n};\n\nexport type RotateCommand = {\n  top: TowerSide,\n  middle: TowerSide,\n  bottom: TowerSide\n}\n\n// prettier-ignore\nexport const drumPositionCmds = {\n  top: { north: 0b00010000, east: 0b00000010, south: 0b00010100, west: 0b00010110 }, // bits 1-8\n  middle: { north: 0b00010000, east: 0b01000000, south: 0b10010000, west: 0b11010000 }, // bits 1-4\n  bottom: { north: 0b01000010, east: 0b01001010, south: 0b01010010, west: 0b01011010 },\n}\n\n\nexport const LIGHT_EFFECTS = {\n  off: 0,\n  on: 1,\n  breathe: 2,\n  breatheFast: 3,\n  breathe50percent: 4,\n  flicker: 5,\n}\n\n\nexport const TOWER_LIGHT_SEQUENCES = {\n  twinkle: 0x01,\n  flareThenFade: 0x02,\n  flareThenFadeBase: 0x03,\n  flareThenFlicker: 0x04,\n  angryStrobe01: 0x05,\n  angryStrobe02: 0x06,\n  angryStrobe03: 0x07,\n  gloat01: 0x08,\n  gloat02: 0x09,\n  gloat03: 0x0a,\n  defeat: 0x0b,\n  victory: 0x0c,\n  dungeonIdle: 0x0d,\n  sealReveal: 0x0e,\n  rotationAllDrums: 0x0f,\n  rotationDrumTop: 0x10,\n  rotationDrumMiddle: 0x11,\n  rotationDrumBottom: 0x12,\n  monthStarted: 0x13,\n}\n\nexport type SoundCategory =\n  \"Adversary\" | \"Ally\" | \"Battle\" |\n  \"Classic\" | \"Unlisted\" | \"Dungeon\" | \"Foe\" |\n  \"Spawn\" | \"Quest\" | \"Glyph\" | \"State\" | \"Seals\";\n\n// Tower Responses\n// prettier-ignore\nexport const TOWER_MESSAGES = {\n  TOWER_STATE: { name: \"Tower State\", value: 0, critical: false },\n  INVALID_STATE: { name: \"Invalid State\", value: 1, critical: true },\n  HARDWARE_FAILURE: { name: \"Hardware Failure\", value: 2, critical: true },\n  MECH_JIGGLE_TRIGGERED: { name: \"Unjam Jiggle Triggered\", value: 3, critical: true },\n  MECH_DURATION: { name: \"Rotation Duration\", value: 4, critical: false },\n  MECH_UNEXPECTED_TRIGGER: { name: \"Unexpected Trigger\", value: 5, critical: true },\n  DIFFERENTIAL_READINGS: { name: \"Diff Voltage Readings\", value: 6, critical: false },\n  BATTERY_READING: { name: \"Battery Level\", value: 7, critical: false },\n  CALIBRATION_FINISHED: { name: \"Calibration Finished\", value: 8, critical: false },\n}\n\n// 5% increments - voltages are in millivolts and typical for a 250mA discharge \n// at room temperature which roughly matches a single Energizer EN91\n// This is a rough approximation as chemical makeup of batteries have differing\n// battery performace (Alkaline vs NiMH vs Li etc).\nexport const VOLTAGE_LEVELS = [\n  1500, 1390, 1350, 1320, 1295, 1270, 1245, 1225, 1205,\n  1180, 1175, 1166, 1150, 1133, 1125, 1107, 1095, 1066, 1033,\n  980 // There's an additional 5% until 800mV is reached\n];\n\n// Tower Layer Mapping Constants (moved from functions.ts)\n// Constants for mapping tower layers to physical locations\nexport const TOWER_LAYERS = {\n  TOP_RING: 0,\n  MIDDLE_RING: 1,\n  BOTTOM_RING: 2,\n  LEDGE: 3,\n  BASE1: 4,\n  BASE2: 5,\n} as const;\n\n// Ring layers use cardinal directions (position 0 = North)\nexport const RING_LIGHT_POSITIONS = {\n  NORTH: 0,\n  EAST: 1,\n  SOUTH: 2,\n  WEST: 3,\n} as const;\n\n// Ledge and Base layers use ordinal directions (position 0 = North-East)\nexport const LEDGE_BASE_LIGHT_POSITIONS = {\n  NORTH_EAST: 0,\n  SOUTH_EAST: 1,\n  SOUTH_WEST: 2,\n  NORTH_WEST: 3,\n} as const;\n\n// LED Channel Lookup (matches firmware implementation)\n// Convert from (layer * 4) + position to LED driver channel (0-23)\nexport const LED_CHANNEL_LOOKUP = [\n  // Layer 0: Top Ring (C0 R0, C0 R3, C0 R2, C0 R1)\n  0, 3, 2, 1,\n  // Layer 1: Middle Ring (C1 R3, C1 R2, C1 R1, C1 R0) \n  7, 6, 5, 4,\n  // Layer 2: Bottom Ring (C2 R2, C2 R1, C2 R0, C2 R3)\n  10, 9, 8, 11,\n  // Layer 3: Ledge (LEDGE R4, LEDGE R5, LEDGE R6, LEDGE R7)\n  12, 13, 14, 15,\n  // Layer 4: Base1 (BASE1 R4, BASE1 R5, BASE1 R6, BASE1 R7)\n  16, 17, 18, 19,\n  // Layer 5: Base2 (BASE2 R4, BASE2 R5, BASE2 R6, BASE2 R7) \n  20, 21, 22, 23,\n];\n\n// Updated reverse mapping for the corrected layer architecture\nexport const LAYER_TO_POSITION = {\n  [TOWER_LAYERS.TOP_RING]: 'TOP_RING',\n  [TOWER_LAYERS.MIDDLE_RING]: 'MIDDLE_RING',\n  [TOWER_LAYERS.BOTTOM_RING]: 'BOTTOM_RING',\n  [TOWER_LAYERS.LEDGE]: 'LEDGE',\n  [TOWER_LAYERS.BASE1]: 'BASE1',\n  [TOWER_LAYERS.BASE2]: 'BASE2'\n} as const;\n\nexport const LIGHT_INDEX_TO_DIRECTION = {\n  [RING_LIGHT_POSITIONS.NORTH]: 'NORTH',\n  [RING_LIGHT_POSITIONS.EAST]: 'EAST',\n  [RING_LIGHT_POSITIONS.SOUTH]: 'SOUTH',\n  [RING_LIGHT_POSITIONS.WEST]: 'WEST'\n} as const;\n\nexport const STATE_DATA_LENGTH = 19;\n\nexport type AudioLibrary = {\n  [name: string]: {\n    name: string,\n    value: number,\n    category: SoundCategory\n  }\n}\n\n// prettier-ignore\nexport const TOWER_AUDIO_LIBRARY: AudioLibrary = {\n  Ashstrider: { name: \"Ashstrider\", value: 0x01, category: \"Adversary\" },\n  BaneofOmens: { name: \"Bane of Omens\", value: 0x02, category: \"Adversary\" },\n  EmpressofShades: { name: \"Empress of Shades\", value: 0x03, category: \"Adversary\" },\n  GazeEternal: { name: \"Gaze Eternal\", value: 0x04, category: \"Adversary\" },\n  Gravemaw: { name: \"Gravemaw\", value: 0x05, category: \"Adversary\" },\n  IsatheHollow: { name: \"Isa the Hollow\", value: 0x06, category: \"Adversary\" },\n  LingeringRot: { name: \"Lingering Rot\", value: 0x07, category: \"Adversary\" },\n  UtukKu: { name: \"Utuk'Ku\", value: 0x08, category: \"Adversary\" },\n  Gleb: { name: \"Gleb\", value: 0x09, category: \"Ally\" },\n  Grigor: { name: \"Grigor\", value: 0x0A, category: \"Ally\" },\n  Hakan: { name: \"Hakan\", value: 0x0B, category: \"Ally\" },\n  Letha: { name: \"Letha\", value: 0x0C, category: \"Ally\" },\n  Miras: { name: \"Miras\", value: 0x0D, category: \"Ally\" },\n  Nimet: { name: \"Nimet\", value: 0x0E, category: \"Ally\" },\n  Tomas: { name: \"Tomas\", value: 0x0F, category: \"Ally\" },\n  Vasa: { name: \"Vasa\", value: 0x10, category: \"Ally\" },\n  Yana: { name: \"Yana\", value: 0x11, category: \"Ally\" },\n  Zaida: { name: \"Zaida\", value: 0x12, category: \"Ally\" },\n  ApplyAdvantage01: { name: \"Apply Advantage 01\", value: 0x13, category: \"Battle\" },\n  ApplyAdvantage02: { name: \"Apply Advantage 02\", value: 0x14, category: \"Battle\" },\n  ApplyAdvantage03: { name: \"Apply Advantage 03\", value: 0x15, category: \"Battle\" },\n  ApplyAdvantage04: { name: \"Apply Advantage 04\", value: 0x16, category: \"Battle\" },\n  ApplyAdvantage05: { name: \"Apply Advantage 05\", value: 0x17, category: \"Battle\" },\n  MaxAdvantages: { name: \"Max Advantages\", value: 0x18, category: \"Battle\" },\n  NoAdvantages: { name: \"No Advantages\", value: 0x19, category: \"Battle\" },\n  AdversaryEscaped: { name: \"Adversary Escaped\", value: 0x1A, category: \"Battle\" },\n  BattleButton: { name: \"Battle Button\", value: 0x1B, category: \"Battle\" },\n  CardFlip01: { name: \"Card Flip 01\", value: 0x1C, category: \"Battle\" },\n  CardFlip02: { name: \"Card Flip 02\", value: 0x1D, category: \"Battle\" },\n  CardFlip03: { name: \"Card Flip 03\", value: 0x1E, category: \"Battle\" },\n  CardFlipPaper01: { name: \"Card Flip Paper 01\", value: 0x1F, category: \"Battle\" },\n  CardFlipPaper02: { name: \"Card Flip Paper 02\", value: 0x20, category: \"Battle\" },\n  CardFlipPaper03: { name: \"Card Flip Paper 03\", value: 0x21, category: \"Battle\" },\n  CardSelect01: { name: \"Card Select 01\", value: 0x22, category: \"Battle\" },\n  CardSelect02: { name: \"Card Select 02\", value: 0x23, category: \"Battle\" },\n  CardSelect03: { name: \"Card Select 03\", value: 0x24, category: \"Battle\" },\n  BattleStart: { name: \"Battle Start\", value: 0x25, category: \"Battle\" },\n  BattleVictory: { name: \"Battle Victory\", value: 0x26, category: \"Battle\" },\n  ButtonHoldPressCombo: { name: \"Button Hold Press Combo\", value: 0x27, category: \"Battle\" },\n  ButtonHold: { name: \"Button Hold\", value: 0x28, category: \"Battle\" },\n  ButtonPress: { name: \"Button Press\", value: 0x29, category: \"Battle\" },\n  ClassicAdvantageApplied: { name: \"8-bit Advantage\", value: 0x2A, category: \"Classic\" },\n  ClassicAttackTower: { name: \"8-bit Attack Tower\", value: 0x2B, category: \"Classic\" },\n  ClassicBazaar: { name: \"8-bit Bazaar\", value: 0x2C, category: \"Classic\" },\n  ClassicConfirmation: { name: \"8-bit Confirmation\", value: 0x2D, category: \"Classic\" },\n  ClassicDragons: { name: \"8-bit Dragons\", value: 0x2E, category: \"Classic\" },\n  ClassicQuestFailed: { name: \"8-bit Quest Failed\", value: 0x2F, category: \"Classic\" },\n  ClassicRetreat: { name: \"8-bit Retreat\", value: 0x30, category: \"Classic\" },\n  ClassicStartMonth: { name: \"8-bit Start Month\", value: 0x31, category: \"Classic\" },\n  ClassicStartDungeon: { name: \"8-bit Start Dungeon\", value: 0x32, category: \"Classic\" },\n  ClassicTowerLost: { name: \"8-bit Tower Lost\", value: 0x33, category: \"Classic\" },\n  ClassicUnsure: { name: \"8-bit Unsure\", value: 0x34, category: \"Classic\" },\n  DungeonAdvantage01: { name: \"Dungeon Advantage 01\", value: 0x35, category: \"Dungeon\" },\n  DungeonAdvantage02: { name: \"Dungeon Advantage 02\", value: 0x36, category: \"Dungeon\" },\n  DungeonButton: { name: \"Dungeon Button\", value: 0x37, category: \"Dungeon\" },\n  DungeonFootsteps: { name: \"Dungeon Footsteps\", value: 0x38, category: \"Dungeon\" },\n  DungeonCaves: { name: \"Dungeon Caves\", value: 0x39, category: \"Dungeon\" },\n  DungeonComplete: { name: \"Dungeon Complete\", value: 0x3A, category: \"Dungeon\" },\n  DungeonEncampment: { name: \"Dungeon Encampment\", value: 0x3B, category: \"Dungeon\" },\n  DungeonEscape: { name: \"Dungeon Escape\", value: 0x3C, category: \"Dungeon\" },\n  DungeonFortress: { name: \"Dungeon Fortress\", value: 0x3D, category: \"Dungeon\" },\n  DungeonRuins: { name: \"Dungeon Ruins\", value: 0x3E, category: \"Dungeon\" },\n  DungeonShrine: { name: \"Dungeon Shrine\", value: 0x3F, category: \"Dungeon\" },\n  DungeonTomb: { name: \"Dungeon Tomb\", value: 0x40, category: \"Dungeon\" },\n  FoeEvent: { name: \"Foe Event\", value: 0x41, category: \"Foe\" },\n  FoeSpawn: { name: \"Foe Spawn\", value: 0x42, category: \"Foe\" },\n  Brigands: { name: \"Brigands\", value: 0x43, category: \"Foe\" },\n  ClanofNeuri: { name: \"Clan of Neuri\", value: 0x44, category: \"Foe\" },\n  Dragons: { name: \"Dragons\", value: 0x45, category: \"Foe\" },\n  Lemures: { name: \"Lemures\", value: 0x46, category: \"Foe\" },\n  LeveledUp: { name: \"Leveled Up\", value: 0x47, category: \"Foe\" },\n  Mormos: { name: \"Mormos\", value: 0x48, category: \"Foe\" },\n  Oreks: { name: \"Oreks\", value: 0x49, category: \"Foe\" },\n  ShadowWolves: { name: \"Shadow Wolves\", value: 0x4A, category: \"Foe\" },\n  SpineFiends: { name: \"Spine Fiends\", value: 0x4B, category: \"Foe\" },\n  Strigas: { name: \"Strigas\", value: 0x4C, category: \"Foe\" },\n  Titans: { name: \"Titans\", value: 0x4D, category: \"Foe\" },\n  FrostTrolls: { name: \"Frost Trolls\", value: 0x4E, category: \"Foe\" },\n  WidowmadeSpiders: { name: \"Widowmade Spiders\", value: 0x4F, category: \"Foe\" },\n  AshstriderSpawn: { name: \"Ashstrider Spawn\", value: 0x50, category: \"Spawn\" },\n  BaneofOmensSpawn: { name: \"Bane of Omens Spawn\", value: 0x51, category: \"Spawn\" },\n  EmpressofShadesSpawn: { name: \"Empress of Shades Spawn\", value: 0x52, category: \"Spawn\" },\n  GazeEternalSpawn: { name: \"Gaze Eternal Spawn\", value: 0x53, category: \"Spawn\" },\n  GravemawSpawn: { name: \"Gravemaw Spawn\", value: 0x54, category: \"Spawn\" },\n  IsatheHollowSpawn: { name: \"Isa the Hollow Spawn\", value: 0x55, category: \"Spawn\" },\n  LingeringRotSpawn: { name: \"Lingering Rot Spawn\", value: 0x56, category: \"Spawn\" },\n  UtukKuSpawn: { name: \"Utuk'Ku Spawn\", value: 0x57, category: \"Spawn\" },\n  QuestComplete: { name: \"Quest Complete\", value: 0x58, category: \"Quest\" },\n  TowerAllGlyphs: { name: \"Tower All Glyphs\", value: 0x59, category: \"Glyph\" },\n  TowerAngry1: { name: \"Tower Angry 1\", value: 0x5A, category: \"Glyph\" },\n  TowerAngry2: { name: \"Tower Angry 2\", value: 0x5B, category: \"Glyph\" },\n  TowerAngry3: { name: \"Tower Angry 3\", value: 0x5C, category: \"Glyph\" },\n  TowerAngry4: { name: \"Tower Angry 4\", value: 0x5D, category: \"Glyph\" },\n  TowerConnected: { name: \"Tower Connected\", value: 0x5E, category: \"State\" },\n  GameStart: { name: \"Game Start\", value: 0x5F, category: \"State\" },\n  TowerGloat1: { name: \"Tower Gloat 1\", value: 0x60, category: \"State\" },\n  TowerGloat2: { name: \"Tower Gloat 2\", value: 0x61, category: \"State\" },\n  TowerGloat3: { name: \"Tower Gloat 3\", value: 0x62, category: \"State\" },\n  TowerGlyph: { name: \"Tower Glyph\", value: 0x63, category: \"State\" },\n  TowerIdle1: { name: \"Tower Idle 1\", value: 0x64, category: \"State\" },\n  TowerIdle2: { name: \"Tower Idle 2\", value: 0x65, category: \"State\" },\n  TowerIdle3: { name: \"Tower Idle 3\", value: 0x66, category: \"State\" },\n  TowerIdle4: { name: \"Tower Idle 4\", value: 0x67, category: \"State\" },\n  TowerIdle5: { name: \"Tower Idle 5\", value: 0x68, category: \"Unlisted\" },\n  TowerDisconnected: { name: \"Tower Disconnect\", value: 0x69, category: \"State\" },\n  MonthEnded: { name: \"Month Ended\", value: 0x6A, category: \"State\" },\n  MonthStarted: { name: \"Month Started\", value: 0x6B, category: \"State\" },\n  QuestFailed: { name: \"Quest Failed\", value: 0x6C, category: \"Quest\" },\n  RotateExit: { name: \"Rotate Exit\", value: 0x6D, category: \"Seals\" },\n  RotateLoop: { name: \"Rotate Loop\", value: 0x6E, category: \"Seals\" },\n  RotateStart: { name: \"Rotate Start\", value: 0x6F, category: \"Seals\" },\n  TowerSeal: { name: \"Tower Seal\", value: 0x70, category: \"Seals\" },\n  TowerSkullDropped: { name: \"Tower Skull Dropped\", value: 0x71, category: \"State\" },\n}\n\n// Volume level descriptions (firmware: 0=loudest, 1=medium, 2=quiet, 3=mute)\nexport const VOLUME_DESCRIPTIONS = {\n  0: 'Loud',\n  1: 'Medium',\n  2: 'Quiet',\n  3: 'Mute'\n} as const;\n\n// Volume level icons\nexport const VOLUME_ICONS = {\n  0: '\uD83D\uDD0A', // Loud - biggest speaker\n  1: '\uD83D\uDD09', // Medium - medium speaker\n  2: '\uD83D\uDD08', // Quiet - small speaker\n  3: '\uD83D\uDD07'  // Mute - muted speaker\n} as const;", "import {\n  TOWER_LAYERS,\n  RING_LIGHT_POSITIONS,\n  LEDGE_BASE_LIGHT_POSITIONS,\n  LED_CHANNEL_LOOKUP,\n  LAYER_TO_POSITION,\n  LIGHT_INDEX_TO_DIRECTION,\n  STATE_DATA_LENGTH\n} from './udtConstants';\n\n// TypeScript interfaces for tower state structure\ninterface Light {\n  effect: number;\n  loop: boolean;\n}\n\ninterface Layer {\n  light: [Light, Light, Light, Light];\n}\n\ninterface Drum {\n  jammed: boolean;\n  calibrated: boolean;\n  position: number;\n  playSound: boolean;\n  reverse: boolean;\n}\n\ninterface Audio {\n  sample: number;\n  loop: boolean;\n  volume: number;\n}\n\ninterface Beam {\n  count: number;\n  fault: boolean;\n}\n\ninterface TowerState {\n  drum: [Drum, Drum, Drum];\n  layer: [Layer, Layer, Layer, Layer, Layer, Layer];\n  audio: Audio;\n  beam: Beam;\n  led_sequence: number;\n}\n\n/**\n * Unpacks binary data from the tower into a structured TowerState object.\n * Extracts drum states, LED configurations, audio settings, beam counter, and LED sequences.\n * \n * @param data - The raw binary data received from the tower (must be at least STATE_DATA_LENGTH bytes)\n * @returns A TowerState object containing all the parsed tower state information\n */\nfunction rtdt_unpack_state(data: Uint8Array): TowerState {\n\n  // Padding is aligns the different sections on byte boundaries\n  const state: TowerState = {\n    drum: [\n      { jammed: false, calibrated: false, position: 0, playSound: false, reverse: false },\n      { jammed: false, calibrated: false, position: 0, playSound: false, reverse: false },\n      { jammed: false, calibrated: false, position: 0, playSound: false, reverse: false }\n    ],\n    layer: [\n      { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] },\n      { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] },\n      { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] },\n      { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] },\n      { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] },\n      { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] }\n    ],\n    audio: { sample: 0, loop: false, volume: 0 },\n    beam: { count: 0, fault: false },\n    led_sequence: 0\n  };\n\n  // Bytes 0-1: Drum states\n  state.drum[0].jammed = !!(data[0] & 0b00001000);\n  state.drum[0].calibrated = !!(data[0] & 0b00010000);\n  state.drum[1].jammed = !!(data[1] & 0b00000001);\n  state.drum[1].calibrated = !!(data[1] & 0b00000010);\n  state.drum[2].jammed = !!(data[1] & 0b00100000);\n  state.drum[2].calibrated = !!(data[1] & 0b01000000);\n\n  // 4 stopping locations, low bit defines whether or not \n  // to play a sound during rotation\n  // not recommended to play sound during rotation due to battery draw\n  state.drum[0].position = (data[0] & 0b00000110) >> 1;\n  state.drum[1].position = (data[0] & 0b11000000) >> 6;\n  state.drum[2].position = (data[1] & 0b00011000) >> 3;\n  state.drum[0].playSound = !!(data[0] & 0b00000001);\n  state.drum[1].playSound = !!(data[0] & 0b00100000);\n  state.drum[2].playSound = !!(data[1] & 0b00000100);\n\n  // Bytes 2-13: LED states\n  state.layer[0].light[0].effect = (data[2] & 0b11100000) >> 5;\n  state.layer[0].light[0].loop = !!(data[2] & 0b00010000);\n  state.layer[0].light[1].effect = (data[2] & 0b00001110) >> 1;\n  state.layer[0].light[1].loop = !!(data[2] & 0b00000001);\n  state.layer[0].light[2].effect = (data[3] & 0b11100000) >> 5;\n  state.layer[0].light[2].loop = !!(data[3] & 0b00010000);\n  state.layer[0].light[3].effect = (data[3] & 0b00001110) >> 1;\n  state.layer[0].light[3].loop = !!(data[3] & 0b00000001);\n\n  state.layer[1].light[0].effect = (data[4] & 0b11100000) >> 5;\n  state.layer[1].light[0].loop = !!(data[4] & 0b00010000);\n  state.layer[1].light[1].effect = (data[4] & 0b00001110) >> 1;\n  state.layer[1].light[1].loop = !!(data[4] & 0b00000001);\n  state.layer[1].light[2].effect = (data[5] & 0b11100000) >> 5;\n  state.layer[1].light[2].loop = !!(data[5] & 0b00010000);\n  state.layer[1].light[3].effect = (data[5] & 0b00001110) >> 1;\n  state.layer[1].light[3].loop = !!(data[5] & 0b00000001);\n\n  state.layer[2].light[0].effect = (data[6] & 0b11100000) >> 5;\n  state.layer[2].light[0].loop = !!(data[6] & 0b00010000);\n  state.layer[2].light[1].effect = (data[6] & 0b00001110) >> 1;\n  state.layer[2].light[1].loop = !!(data[6] & 0b00000001);\n  state.layer[2].light[2].effect = (data[7] & 0b11100000) >> 5;\n  state.layer[2].light[2].loop = !!(data[7] & 0b00010000);\n  state.layer[2].light[3].effect = (data[7] & 0b00001110) >> 1;\n  state.layer[2].light[3].loop = !!(data[7] & 0b00000001);\n\n  state.layer[3].light[0].effect = (data[8] & 0b11100000) >> 5;\n  state.layer[3].light[0].loop = !!(data[8] & 0b00010000);\n  state.layer[3].light[1].effect = (data[8] & 0b00001110) >> 1;\n  state.layer[3].light[1].loop = !!(data[8] & 0b00000001);\n  state.layer[3].light[2].effect = (data[9] & 0b11100000) >> 5;\n  state.layer[3].light[2].loop = !!(data[9] & 0b00010000);\n  state.layer[3].light[3].effect = (data[9] & 0b00001110) >> 1;\n  state.layer[3].light[3].loop = !!(data[9] & 0b00000001);\n\n  state.layer[4].light[0].effect = (data[10] & 0b11100000) >> 5;\n  state.layer[4].light[0].loop = !!(data[10] & 0b00010000);\n  state.layer[4].light[1].effect = (data[10] & 0b00001110) >> 1;\n  state.layer[4].light[1].loop = !!(data[10] & 0b00000001);\n  state.layer[4].light[2].effect = (data[11] & 0b11100000) >> 5;\n  state.layer[4].light[2].loop = !!(data[11] & 0b00010000);\n  state.layer[4].light[3].effect = (data[11] & 0b00001110) >> 1;\n  state.layer[4].light[3].loop = !!(data[11] & 0b00000001);\n\n  state.layer[5].light[0].effect = (data[12] & 0b11100000) >> 5;\n  state.layer[5].light[0].loop = !!(data[12] & 0b00010000);\n  state.layer[5].light[1].effect = (data[12] & 0b00001110) >> 1;\n  state.layer[5].light[1].loop = !!(data[12] & 0b00000001);\n  state.layer[5].light[2].effect = (data[13] & 0b11100000) >> 5;\n  state.layer[5].light[2].loop = !!(data[13] & 0b00010000);\n  state.layer[5].light[3].effect = (data[13] & 0b00001110) >> 1;\n  state.layer[5].light[3].loop = !!(data[13] & 0b00000001);\n\n  // Byte 14: Audio\n  state.audio.sample = data[14] & 0b01111111;\n  state.audio.loop = !!(data[14] & 0b10000000);\n\n  // Bytes 15-17: Beam, drum-reversing, volume\n  // DO NOT run the drums in reverse!\n  state.beam.count = (data[15] << 8) | data[16];\n  state.beam.fault = !!(data[17] & 0b00000001);\n  state.drum[0].reverse = !!(data[17] & 0b00000010); // DON'T\n  state.drum[1].reverse = !!(data[17] & 0b00000100); // USE\n  state.drum[2].reverse = !!(data[17] & 0b00001000); // THESE\n  state.audio.volume = (data[17] & 0b11110000) >> 4;\n\n  // Byte 18: LED sequences\n  state.led_sequence = data[18];\n\n  return state;\n}\n\n/**\n * Packs a TowerState object into binary data format for transmission to the tower.\n * Serializes drum states, LED configurations, audio settings, beam counter, and LED sequences.\n * \n * @param data - The output buffer to write the packed data to\n * @param len - The length of the output buffer (must be at least STATE_DATA_LENGTH)\n * @param state - The TowerState object to pack into binary format\n * @returns True if packing was successful, false if the buffer is too small or invalid\n */\nfunction rtdt_pack_state(data: Uint8Array, len: number, state: TowerState): boolean {\n  if (!data || len < STATE_DATA_LENGTH)\n    return false;\n\n  // Clear the data array\n  data.fill(0, 0, STATE_DATA_LENGTH);\n\n  // Pack drum states\n  data[0] |= (state.drum[0].playSound ? 1 : 0) |\n    (((state.drum[0].position) & 0b11) << 1) |\n    ((state.drum[0].jammed ? 1 : 0) << 3) |\n    ((state.drum[0].calibrated ? 1 : 0) << 4) |\n    ((state.drum[1].playSound ? 1 : 0) << 5) |\n    (((state.drum[1].position) & 0b11) << 6);\n\n  data[1] |= (state.drum[1].jammed ? 1 : 0) |\n    ((state.drum[1].calibrated ? 1 : 0) << 1) |\n    ((state.drum[2].playSound ? 1 : 0) << 2) |\n    (((state.drum[2].position) & 0b11) << 3) |\n    ((state.drum[2].jammed ? 1 : 0) << 5) |\n    ((state.drum[2].calibrated ? 1 : 0) << 6);\n\n  // Pack LED states\n  data[2] |= (state.layer[0].light[0].effect << 5) | ((state.layer[0].light[0].loop ? 1 : 0) << 4);\n  data[2] |= (state.layer[0].light[1].effect << 1) | (state.layer[0].light[1].loop ? 1 : 0);\n  data[3] |= (state.layer[0].light[2].effect << 5) | ((state.layer[0].light[2].loop ? 1 : 0) << 4);\n  data[3] |= (state.layer[0].light[3].effect << 1) | (state.layer[0].light[3].loop ? 1 : 0);\n\n  data[4] |= (state.layer[1].light[0].effect << 5) | ((state.layer[1].light[0].loop ? 1 : 0) << 4);\n  data[4] |= (state.layer[1].light[1].effect << 1) | (state.layer[1].light[1].loop ? 1 : 0);\n  data[5] |= (state.layer[1].light[2].effect << 5) | ((state.layer[1].light[2].loop ? 1 : 0) << 4);\n  data[5] |= (state.layer[1].light[3].effect << 1) | (state.layer[1].light[3].loop ? 1 : 0);\n\n  data[6] |= (state.layer[2].light[0].effect << 5) | ((state.layer[2].light[0].loop ? 1 : 0) << 4);\n  data[6] |= (state.layer[2].light[1].effect << 1) | (state.layer[2].light[1].loop ? 1 : 0);\n  data[7] |= (state.layer[2].light[2].effect << 5) | ((state.layer[2].light[2].loop ? 1 : 0) << 4);\n  data[7] |= (state.layer[2].light[3].effect << 1) | (state.layer[2].light[3].loop ? 1 : 0);\n\n  data[8] |= (state.layer[3].light[0].effect << 5) | ((state.layer[3].light[0].loop ? 1 : 0) << 4);\n  data[8] |= (state.layer[3].light[1].effect << 1) | (state.layer[3].light[1].loop ? 1 : 0);\n  data[9] |= (state.layer[3].light[2].effect << 5) | ((state.layer[3].light[2].loop ? 1 : 0) << 4);\n  data[9] |= (state.layer[3].light[3].effect << 1) | (state.layer[3].light[3].loop ? 1 : 0);\n\n  data[10] |= (state.layer[4].light[0].effect << 5) | ((state.layer[4].light[0].loop ? 1 : 0) << 4);\n  data[10] |= (state.layer[4].light[1].effect << 1) | (state.layer[4].light[1].loop ? 1 : 0);\n  data[11] |= (state.layer[4].light[2].effect << 5) | ((state.layer[4].light[2].loop ? 1 : 0) << 4);\n  data[11] |= (state.layer[4].light[3].effect << 1) | (state.layer[4].light[3].loop ? 1 : 0);\n\n  data[12] |= (state.layer[5].light[0].effect << 5) | ((state.layer[5].light[0].loop ? 1 : 0) << 4);\n  data[12] |= (state.layer[5].light[1].effect << 1) | (state.layer[5].light[1].loop ? 1 : 0);\n  data[13] |= (state.layer[5].light[2].effect << 5) | ((state.layer[5].light[2].loop ? 1 : 0) << 4);\n  data[13] |= (state.layer[5].light[3].effect << 1) | (state.layer[5].light[3].loop ? 1 : 0);\n\n  // Pack audio state\n  data[14] = (state.audio.sample | ((state.audio.loop ? 1 : 0) << 7));\n\n  // Pack beam-break counter state, and drum reversal\n  data[15] = (state.beam.count >> 8);\n  data[16] = (state.beam.count & 0xFF);\n  data[17] = (state.audio.volume << 4) |\n    ((state.beam.fault ? 1 : 0)) |\n    ((state.drum[0].reverse ? 1 : 0) << 1) |\n    ((state.drum[1].reverse ? 1 : 0) << 2) |\n    ((state.drum[2].reverse ? 1 : 0) << 3);\n\n  // Pack LED override state\n  data[18] = state.led_sequence;\n\n  return true;\n}\n\n/**\n * Checks if all drums in the tower are calibrated.\n * A tower is considered fully calibrated only when all three drums have completed their calibration process.\n * \n * @param state - The TowerState object to check\n * @returns True if all drums are calibrated, false if any drum is not calibrated\n */\nfunction isCalibrated(state: TowerState): boolean {\n  return state.drum.every(drum => drum.calibrated);\n}\n\n\n// Export the functions and types for use elsewhere\nexport type { TowerState, Light, Layer, Drum, Audio, Beam };\nexport {\n  rtdt_unpack_state,\n  rtdt_pack_state,\n  isCalibrated,\n  STATE_DATA_LENGTH,\n  TOWER_LAYERS,\n  RING_LIGHT_POSITIONS,\n  LEDGE_BASE_LIGHT_POSITIONS,\n  LED_CHANNEL_LOOKUP,\n  LAYER_TO_POSITION,\n  LIGHT_INDEX_TO_DIRECTION\n};", "import {\n  type Lights,\n  type TowerSide,\n  type TowerLevels,\n  type SealIdentifier,\n  type Glyphs,\n  GLYPHS,\n  TOWER_COMMAND_PACKET_SIZE,\n  TOWER_STATE_DATA_SIZE,\n  TOWER_STATE_RESPONSE_MIN_LENGTH,\n  TOWER_STATE_DATA_OFFSET,\n  TOWER_COMMAND_TYPE_TOWER_STATE,\n  DEFAULT_RETRY_SEND_COMMAND_MAX,\n  DEFAULT_CONNECTION_MONITORING_FREQUENCY,\n  DEFAULT_CONNECTION_MONITORING_TIMEOUT,\n  DEFAULT_BATTERY_HEARTBEAT_TIMEOUT,\n  TOWER_SIDES_COUNT\n} from './udtConstants';\nimport { type TowerState, isCalibrated } from './udtTowerState';\nimport { createDefaultTowerState, milliVoltsToPercentageNumber, commandToPacketString, milliVoltsToPercentage } from './udtHelpers';\nimport { Logger, ConsoleOutput, type LogOutput } from './udtLogger';\nimport { UdtBleConnection, type TowerEventCallbacks, type ConnectionStatus } from './udtBleConnection';\nimport { TowerResponseProcessor } from './udtTowerResponse';\nimport { UdtCommandFactory } from './udtCommandFactory';\nimport { UdtTowerCommands, type TowerCommandDependencies } from './udtTowerCommands';\n\n/**\n * Configuration interface for controlling which tower responses should be logged\n */\ninterface TowerResponseConfig {\n  TOWER_STATE: boolean;\n  INVALID_STATE: boolean;\n  HARDWARE_FAILURE: boolean;\n  MECH_JIGGLE_TRIGGERED: boolean;\n  MECH_UNEXPECTED_TRIGGER: boolean;\n  MECH_DURATION: boolean;\n  DIFFERENTIAL_READINGS: boolean;\n  BATTERY_READING: boolean;\n  CALIBRATION_FINISHED: boolean;\n  LOG_ALL: boolean;\n}\n\n/**\n * @title UltimateDarkTower\n * @description\n * The UltimateDarkTower class is the main control interface for the Return To Dark Tower board game device.\n * It provides a comprehensive API for interacting with the tower through Bluetooth Low Energy (BLE).\n * \n * Usage:\n * 1. Create instance: const tower = new UltimateDarkTower()\n * 2. Connect to tower: await tower.connect()\n * 3. Calibrate tower: await tower.calibrate()\n * 4. Use tower commands: await tower.playSound(1), await tower.Lights({...}), etc.\n * 5. Clean up: await tower.cleanup()\n * \n * Event Callbacks:\n * - onTowerConnect: Called when tower connects\n * - onTowerDisconnect: Called when tower disconnects\n * - onCalibrationComplete: Called when calibration finishes\n * - onSkullDrop: Called when skulls are dropped into the tower\n * - onBatteryLevelNotify: Called when battery level updates\n * - onTowerStateUpdate: Called whenever the tower state is updated\n */\n\nclass UltimateDarkTower {\n  // logging\n  private logger: Logger;\n\n  // connection management\n  private bleConnection: UdtBleConnection;\n  private towerEventCallbacks!: TowerEventCallbacks;\n\n  // response processing\n  private responseProcessor: TowerResponseProcessor;\n\n  // command creation\n  private commandFactory: UdtCommandFactory;\n\n  // tower commands\n  private towerCommands: UdtTowerCommands;\n\n  // tower configuration\n  private retrySendCommandCountRef = { value: 0 };\n  retrySendCommandMax: number = DEFAULT_RETRY_SEND_COMMAND_MAX;\n\n  // tower state\n  currentBatteryValue: number = 0;\n  previousBatteryValue: number = 0;\n  currentBatteryPercentage: number = 0;\n  previousBatteryPercentage: number = 0;\n  private brokenSeals: Set<string> = new Set();\n\n  // Complete tower state tracking for stateful commands\n  private currentTowerState: TowerState = createDefaultTowerState();\n\n  // glyph position tracking\n  private glyphPositions: { [key in Glyphs]: TowerSide | null } = {\n    cleanse: null,\n    quest: null,\n    battle: null,\n    banner: null,\n    reinforce: null\n  };\n\n  // Event callback functions\n  // Override these with your own functions to handle events in your app\n  onTowerConnect = (): void => { };\n  onTowerDisconnect = (): void => { };\n  onCalibrationComplete = (): void => { };\n  onSkullDrop = (towerSkullCount: number): void => { void towerSkullCount; };\n  onBatteryLevelNotify = (millivolts: number): void => { void millivolts; };\n  onTowerStateUpdate = (newState: TowerState, oldState: TowerState, source: string): void => {\n    void newState; void oldState; void source;\n  };\n\n  constructor() {\n    this.initializeLogger();\n    this.initializeComponents();\n    this.setupTowerResponseCallback();\n  }\n\n  /**\n   * Initialize the logger with default console output\n   */\n  private initializeLogger(): void {\n    this.logger = new Logger();\n    this.logger.addOutput(new ConsoleOutput());\n  }\n\n  /**\n   * Initialize all tower components and their dependencies\n   */\n  private initializeComponents(): void {\n    // Initialize BLE connection with tower event handlers\n    this.towerEventCallbacks = this.createTowerEventCallbacks();\n    this.bleConnection = new UdtBleConnection(this.logger, this.towerEventCallbacks);\n\n    // Initialize response processor\n    this.responseProcessor = new TowerResponseProcessor(this.logDetail);\n\n    // Initialize command factory\n    this.commandFactory = new UdtCommandFactory();\n\n    // Initialize tower commands with dependencies\n    const commandDependencies = this.createCommandDependencies();\n    this.towerCommands = new UdtTowerCommands(commandDependencies);\n  }\n\n  /**\n   * Set up the tower response callback after all components are initialized\n   */\n  private setupTowerResponseCallback(): void {\n    this.towerEventCallbacks.onTowerResponse = (response: Uint8Array) => {\n      // Handle command queue response processing (existing functionality)\n      this.towerCommands.onTowerResponse();\n\n      // Check if this is a tower state response and update our state tracking\n      if (response.length >= TOWER_STATE_RESPONSE_MIN_LENGTH) {\n        const { cmdKey } = this.responseProcessor.getTowerCommand(response[0]);\n        if (this.responseProcessor.isTowerStateResponse(cmdKey)) {\n          // Extract the 19-byte state data (skip command byte)\n          const stateData = response.slice(TOWER_STATE_DATA_OFFSET, TOWER_STATE_RESPONSE_MIN_LENGTH);\n          this.updateTowerStateFromResponse(stateData);\n        }\n      }\n    };\n  }  /**\n   * Create tower event callbacks for BLE connection\n   */\n  private createTowerEventCallbacks(): TowerEventCallbacks {\n    return {\n      onTowerConnect: () => this.onTowerConnect(),\n      onTowerDisconnect: () => {\n        this.onTowerDisconnect();\n        // Clear the command queue on disconnection to prevent hanging commands\n        if (this.towerCommands) {\n          this.towerCommands.clearQueue();\n        }\n      },\n      onBatteryLevelNotify: (millivolts: number) => {\n        this.updateBatteryState(millivolts);\n        this.onBatteryLevelNotify(millivolts);\n      },\n      onCalibrationComplete: () => {\n        this.setGlyphPositionsFromCalibration();\n        this.onCalibrationComplete();\n      },\n      onSkullDrop: (towerSkullCount: number) => this.onSkullDrop(towerSkullCount),\n      // onTowerResponse will be set up after tower commands are initialized\n      onTowerResponse: () => { /* will be overridden */ }\n    };\n  }\n\n  /**\n   * Create command dependencies object for tower commands\n   */\n  private createCommandDependencies(): TowerCommandDependencies {\n    return {\n      logger: this.logger,\n      commandFactory: this.commandFactory,\n      bleConnection: this.bleConnection,\n      responseProcessor: this.responseProcessor,\n      logDetail: this.logDetail,\n      retrySendCommandCount: this.retrySendCommandCountRef,\n      retrySendCommandMax: this.retrySendCommandMax,\n      getCurrentTowerState: () => this.currentTowerState,\n      setTowerState: (newState: TowerState, source: string) => this.setTowerState(newState, source)\n    };\n  }\n\n  /**\n   * Update battery state values\n   */\n  private updateBatteryState(millivolts: number): void {\n    this.previousBatteryValue = this.currentBatteryValue;\n    this.currentBatteryValue = millivolts;\n    this.previousBatteryPercentage = this.currentBatteryPercentage;\n    this.currentBatteryPercentage = milliVoltsToPercentageNumber(millivolts);\n  }\n\n  // utility\n  private _logDetail = false;\n\n  get logDetail(): boolean {\n    return this._logDetail;\n  }\n\n  set logDetail(value: boolean) {\n    this._logDetail = value;\n    this.responseProcessor.setDetailedLogging(value);\n\n    // Update dependencies if towerCommands is already initialized\n    if (this.towerCommands) {\n      this.updateTowerCommandDependencies();\n    }\n  }\n\n  /**\n   * Update tower command dependencies when configuration changes\n   */\n  private updateTowerCommandDependencies(): void {\n    const commandDependencies = this.createCommandDependencies();\n    this.towerCommands = new UdtTowerCommands(commandDependencies);\n  }\n\n  // Getter methods for connection state\n  get isConnected(): boolean { return this.bleConnection.isConnected; }\n  get isCalibrated(): boolean { return isCalibrated(this.currentTowerState); }\n  get performingCalibration(): boolean { return this.bleConnection.performingCalibration; }\n  get performingLongCommand(): boolean { return this.bleConnection.performingLongCommand; }\n  get towerSkullDropCount(): number { return this.bleConnection.towerSkullDropCount; }\n  get txCharacteristic() { return this.bleConnection.txCharacteristic; }\n\n  // Getter methods for battery state\n  get currentBattery(): number { return this.currentBatteryValue; }\n  get previousBattery(): number { return this.previousBatteryValue; }\n  get currentBatteryPercent(): number { return this.currentBatteryPercentage; }\n  get previousBatteryPercent(): number { return this.previousBatteryPercentage; }\n\n  // Getter/setter methods for connection configuration\n  get batteryNotifyFrequency(): number { return this.bleConnection.batteryNotifyFrequency; }\n  set batteryNotifyFrequency(value: number) { this.bleConnection.batteryNotifyFrequency = value; }\n\n  get batteryNotifyOnValueChangeOnly(): boolean { return this.bleConnection.batteryNotifyOnValueChangeOnly; }\n  set batteryNotifyOnValueChangeOnly(value: boolean) { this.bleConnection.batteryNotifyOnValueChangeOnly = value; }\n\n  get batteryNotifyEnabled(): boolean { return this.bleConnection.batteryNotifyEnabled; }\n  set batteryNotifyEnabled(value: boolean) { this.bleConnection.batteryNotifyEnabled = value; }\n\n  get logTowerResponses(): boolean { return this.bleConnection.logTowerResponses; }\n  set logTowerResponses(value: boolean) { this.bleConnection.logTowerResponses = value; }\n\n  get logTowerResponseConfig(): TowerResponseConfig { return this.bleConnection.logTowerResponseConfig; }\n  set logTowerResponseConfig(value: TowerResponseConfig) { this.bleConnection.logTowerResponseConfig = value; }\n\n  //#region Tower Commands \n  /**\n   * Initiates tower calibration to determine the current position of all tower drums.\n   * This must be performed after connection before other tower operations.\n   * @returns Promise that resolves when calibration command is sent\n   */\n  async calibrate(): Promise<void> {\n    return this.towerCommands.calibrate();\n  }\n\n\n  /**\n   * Plays a sound from the tower's audio library.\n   * @param soundIndex - Index of the sound to play (1-based, must be valid in TOWER_AUDIO_LIBRARY)\n   * @returns Promise that resolves when sound command is sent\n   */\n  async playSound(soundIndex: number): Promise<void> {\n    return this.towerCommands.playSound(soundIndex);\n  }\n\n  /**\n   * Controls the tower's LED lights including doorway, ledge, and base lights.\n   * @param lights - Light configuration object specifying which lights to control and their effects\n   * @returns Promise that resolves when light command is sent\n   */\n  async lights(lights: Lights): Promise<void> {\n    return this.towerCommands.lights(lights);\n  }\n\n  /**\n   * Controls the tower's LED lights including doorway, ledge, and base lights.\n   * @deprecated Use `lights()` instead. This method will be removed in a future version.\n   * @param lights - Light configuration object specifying which lights to control and their effects\n   * @returns Promise that resolves when light command is sent\n   */\n  async Lights(lights: Lights): Promise<void> {\n    return this.lights(lights);\n  }\n\n  /**\n   * Sends a raw command packet directly to the tower (for testing purposes).\n   * @param command - The raw command packet to send\n   * @returns Promise that resolves when command is sent\n   */\n  async sendTowerCommandDirect(command: Uint8Array): Promise<void> {\n    return this.towerCommands.sendTowerCommandDirectPublic(command);\n  }\n\n  /**\n   * Sends a light override command to control specific light patterns.\n   * @param light - Light override value to send\n   * @param soundIndex - Optional sound to play with the light override\n   * @returns Promise that resolves when light override command is sent\n   */\n  async lightOverrides(light: number, soundIndex?: number) {\n    return await this.towerCommands.lightOverrides(light, soundIndex);\n  }\n\n  /**\n   * Rotates tower drums to specified positions.\n   * @param top - Position for the top drum ('north', 'east', 'south', 'west')\n   * @param middle - Position for the middle drum\n   * @param bottom - Position for the bottom drum\n   * @param soundIndex - Optional sound to play during rotation\n   * @returns Promise that resolves when rotate command is sent\n   */\n  async Rotate(top: TowerSide, middle: TowerSide, bottom: TowerSide, soundIndex?: number) {\n    // Store current drum positions before rotation\n    const oldTopPosition = this.getCurrentDrumPosition('top');\n    const oldMiddlePosition = this.getCurrentDrumPosition('middle');\n    const oldBottomPosition = this.getCurrentDrumPosition('bottom');\n\n    const result = await this.towerCommands.rotate(top, middle, bottom, soundIndex);\n\n    // Calculate rotation steps for each level and update glyph positions\n    this.calculateAndUpdateGlyphPositions('top', oldTopPosition, top);\n    this.calculateAndUpdateGlyphPositions('middle', oldMiddlePosition, middle);\n    this.calculateAndUpdateGlyphPositions('bottom', oldBottomPosition, bottom);\n\n    return result;\n  }\n\n  /**\n   * Resets the tower's internal skull drop counter to zero.\n   * @returns Promise that resolves when reset command is sent\n   */\n  async resetTowerSkullCount() {\n    return await this.towerCommands.resetTowerSkullCount();\n  }\n\n  //#endregion\n\n  //#region Stateful Tower Commands\n\n  /**\n   * Sets a specific LED using stateful commands that preserve all other tower state.\n   * This is the recommended way to control individual LEDs.\n   * @param layerIndex - Layer index (0-5: TopRing, MiddleRing, BottomRing, Ledge, Base1, Base2)\n   * @param lightIndex - Light index within layer (0-3)\n   * @param effect - Light effect (0=off, 1=on, 2=slow pulse, 3=fast pulse, etc.)\n   * @param loop - Whether to loop the effect\n   * @returns Promise that resolves when command is sent\n   */\n  async setLED(layerIndex: number, lightIndex: number, effect: number, loop: boolean = false): Promise<void> {\n    return await this.towerCommands.setLEDStateful(layerIndex, lightIndex, effect, loop);\n  }\n\n  /**\n   * Plays a sound using stateful commands that preserve existing tower state.\n   * @param soundIndex - Index of the sound to play (1-based)\n   * @param loop - Whether to loop the audio\n   * @param volume - Audio volume (0-15), optional\n   * @returns Promise that resolves when command is sent\n   */\n  async playSoundStateful(soundIndex: number, loop: boolean = false, volume?: number): Promise<void> {\n    return await this.towerCommands.playSoundStateful(soundIndex, loop, volume);\n  }\n\n  /**\n   * Rotates a single drum using stateful commands that preserve existing tower state.\n   * @param drumIndex - Drum index (0=top, 1=middle, 2=bottom)\n   * @param position - Target position (0=north, 1=east, 2=south, 3=west)\n   * @param playSound - Whether to play sound during rotation\n   * @returns Promise that resolves when command is sent\n   */\n  async rotateDrumStateful(drumIndex: number, position: number, playSound: boolean = false): Promise<void> {\n    return await this.towerCommands.rotateDrumStateful(drumIndex, position, playSound);\n  }\n\n  /**\n   * Rotates tower drums to specified positions using stateful commands that preserve existing tower state.\n   * This is the recommended way to rotate drums as it preserves LEDs and other tower state.\n   * @param top - Position for the top drum ('north', 'east', 'south', 'west')\n   * @param middle - Position for the middle drum\n   * @param bottom - Position for the bottom drum\n   * @param soundIndex - Optional sound to play during rotation\n   * @returns Promise that resolves when rotate command is sent\n   */\n  async rotateWithState(top: TowerSide, middle: TowerSide, bottom: TowerSide, soundIndex?: number) {\n    // Store current drum positions before rotation\n    const oldTopPosition = this.getCurrentDrumPosition('top');\n    const oldMiddlePosition = this.getCurrentDrumPosition('middle');\n    const oldBottomPosition = this.getCurrentDrumPosition('bottom');\n\n    const result = await this.towerCommands.rotateWithState(top, middle, bottom, soundIndex);\n\n    // Calculate rotation steps for each level and update glyph positions\n    this.calculateAndUpdateGlyphPositions('top', oldTopPosition, top);\n    this.calculateAndUpdateGlyphPositions('middle', oldMiddlePosition, middle);\n    this.calculateAndUpdateGlyphPositions('bottom', oldBottomPosition, bottom);\n\n    return result;\n  }\n\n  //#endregion\n\n  //#region Tower State Management\n\n  /**\n   * Gets the current complete tower state if available.\n   * @returns The current tower state object\n   */\n  getCurrentTowerState(): TowerState {\n    return { ...this.currentTowerState };\n  }\n\n  /**\n   * Sends a complete tower state to the tower, preserving existing state.\n   * Audio state is automatically cleared to prevent sounds from persisting across commands.\n   * @param towerState - The tower state to send\n   * @returns Promise that resolves when the command is sent\n   */\n  async sendTowerState(towerState: TowerState): Promise<void> {\n    // Import pack function here to avoid circular dependencies\n    const { rtdt_pack_state } = await import('./udtTowerState');\n\n    // Create a copy of the tower state and clear audio to prevent persistence\n    const stateToSend = { ...towerState };\n    stateToSend.audio = { sample: 0, loop: false, volume: 0 };\n\n    // Pack the tower state into 19 bytes\n    const stateData = new Uint8Array(TOWER_STATE_DATA_SIZE);\n    const success = rtdt_pack_state(stateData, TOWER_STATE_DATA_SIZE, stateToSend);\n\n    if (!success) {\n      throw new Error('Failed to pack tower state data');\n    }\n\n    // Create 20-byte command packet (command type 0x00 + 19 bytes state)\n    const command = new Uint8Array(TOWER_COMMAND_PACKET_SIZE);\n    command[0] = TOWER_COMMAND_TYPE_TOWER_STATE; // Command type for tower state\n    command.set(stateData, TOWER_STATE_DATA_OFFSET);\n\n    // Update our current state tracking (also without audio)\n    this.setTowerState({ ...stateToSend }, 'sendTowerState');\n\n    // Send the command\n    return await this.sendTowerCommandDirect(command);\n  }\n\n  /**\n   * Sets the tower state with comprehensive logging of changes.\n   * @param newState - The new tower state to set\n   * @param source - Source identifier for logging (e.g., \"sendTowerState\", \"tower response\")\n   */\n  private setTowerState(newState: TowerState, source: string): void {\n    const oldState = this.currentTowerState;\n    this.currentTowerState = newState;\n\n    // Use the logger's tower state change method\n    this.logger.logTowerStateChange(oldState, newState, source, this.logDetail);\n\n    // Call the tower state update callback\n    this.onTowerStateUpdate(newState, oldState, source);\n  }\n\n  /**\n   * Updates the current tower state from a tower response.\n   * Called internally when tower state responses are received.\n   * Audio state is reset to prevent sounds from persisting across commands.\n   * @param stateData - The 19-byte state data from tower response\n   */\n  private updateTowerStateFromResponse(stateData: Uint8Array): void {\n    // Import unpack function here to avoid circular dependencies\n    import('./udtTowerState').then(({ rtdt_unpack_state }) => {\n      const newState = rtdt_unpack_state(stateData);\n\n      // Reset audio state to prevent sounds from persisting, but preserve user's volume setting\n      // Tower always returns volume=0, so we keep the current volume from our local state\n      newState.audio = { sample: 0, loop: false, volume: this.currentTowerState.audio.volume };\n\n      this.setTowerState(newState, 'tower response');\n    });\n  }\n\n  //#endregion\n\n  /**\n   * Breaks a single seal on the tower, playing appropriate sound and lighting effects.\n   * @param seal - Seal identifier to break (e.g., {side: 'north', level: 'middle'})\n   * @param volume - Optional volume override (0=loud, 1=medium, 2=quiet, 3=mute). Uses current tower state if not provided.\n   * @returns Promise that resolves when seal break sequence is complete\n   */\n  async breakSeal(seal: SealIdentifier, volume?: number) {\n    const result = await this.towerCommands.breakSeal(seal, volume);\n\n    // Track broken seal\n    const sealKey = `${seal.level}-${seal.side}`;\n    this.brokenSeals.add(sealKey);\n\n    return result;\n  }\n\n  /**\n   * Randomly rotates specified tower levels to random positions.\n   * @param level - Level configuration: 0=all, 1=top, 2=middle, 3=bottom, 4=top&middle, 5=top&bottom, 6=middle&bottom\n   * @returns Promise that resolves when rotation command is sent\n   */\n  async randomRotateLevels(level: number = 0) {\n    // Store positions before rotation to calculate what changed\n    const beforeTop = this.getCurrentDrumPosition('top');\n    const beforeMiddle = this.getCurrentDrumPosition('middle');\n    const beforeBottom = this.getCurrentDrumPosition('bottom');\n\n    const result = await this.towerCommands.randomRotateLevels(level);\n\n    // Update glyph positions based on what levels were rotated\n    const afterTop = this.getCurrentDrumPosition('top');\n    const afterMiddle = this.getCurrentDrumPosition('middle');\n    const afterBottom = this.getCurrentDrumPosition('bottom');\n\n    if (beforeTop !== afterTop) {\n      this.calculateAndUpdateGlyphPositions('top', beforeTop, afterTop);\n    }\n    if (beforeMiddle !== afterMiddle) {\n      this.calculateAndUpdateGlyphPositions('middle', beforeMiddle, afterMiddle);\n    }\n    if (beforeBottom !== afterBottom) {\n      this.calculateAndUpdateGlyphPositions('bottom', beforeBottom, afterBottom);\n    }\n\n    return result;\n  }\n\n  /**\n   * Gets the current position of a specific drum level.\n   * @param level - The drum level to get position for\n   * @returns The current position of the specified drum level\n   */\n  getCurrentDrumPosition(level: 'top' | 'middle' | 'bottom'): TowerSide {\n    return this.towerCommands.getCurrentDrumPosition(level);\n  }\n\n  /**\n   * Sets the initial glyph positions from calibration.\n   * Called automatically when calibration completes.\n   */\n  private setGlyphPositionsFromCalibration(): void {\n    for (const glyphKey in GLYPHS) {\n      const glyph = glyphKey as Glyphs;\n      this.glyphPositions[glyph] = GLYPHS[glyph].side as TowerSide;\n    }\n  }\n\n  /**\n   * Gets the current position of a specific glyph.\n   * @param glyph - The glyph to get position for\n   * @returns The current position of the glyph, or null if not calibrated\n   */\n  getGlyphPosition(glyph: Glyphs): TowerSide | null {\n    return this.glyphPositions[glyph];\n  }\n\n  /**\n   * Gets all current glyph positions.\n   * @returns Object mapping each glyph to its current position (or null if not calibrated)\n   */\n  getAllGlyphPositions(): { [key in Glyphs]: TowerSide | null } {\n    return { ...this.glyphPositions };\n  }\n\n  /**\n   * Gets all glyphs currently facing a specific direction.\n   * @param direction - The direction to check for (north, east, south, west)\n   * @returns Array of glyph names that are currently facing the specified direction\n   */\n  getGlyphsFacingDirection(direction: TowerSide): Glyphs[] {\n    const glyphsFacing: Glyphs[] = [];\n\n    for (const glyphKey in this.glyphPositions) {\n      const glyph = glyphKey as Glyphs;\n      const position = this.glyphPositions[glyph];\n\n      if (position && position.toLowerCase() === direction.toLowerCase()) {\n        glyphsFacing.push(glyph);\n      }\n    }\n\n    return glyphsFacing;\n  }\n\n  /**\n   * Updates glyph positions after a drum rotation.\n   * @param level - The drum level that was rotated\n   * @param rotationSteps - Number of steps rotated (1 = 90 degrees clockwise)\n   */\n  private updateGlyphPositionsAfterRotation(level: TowerLevels, rotationSteps: number): void {\n    // Define the rotation order (clockwise)\n    const sides: TowerSide[] = ['north', 'east', 'south', 'west'];\n\n    // Find glyphs on the rotated level\n    for (const glyphKey in GLYPHS) {\n      const glyph = glyphKey as Glyphs;\n      const glyphData = GLYPHS[glyph];\n\n      if (glyphData.level === level && this.glyphPositions[glyph] !== null) {\n        const currentPosition = this.glyphPositions[glyph]!;\n        const currentIndex = sides.indexOf(currentPosition);\n        const newIndex = (currentIndex + rotationSteps) % sides.length;\n        this.glyphPositions[glyph] = sides[newIndex];\n      }\n    }\n  }\n\n  /**\n   * Calculates rotation steps and updates glyph positions for a specific level.\n   * @param level - The drum level that was rotated\n   * @param oldPosition - The position before rotation\n   * @param newPosition - The position after rotation\n   */\n  private calculateAndUpdateGlyphPositions(level: TowerLevels, oldPosition: TowerSide, newPosition: TowerSide): void {\n    // Calculate rotation steps\n    const sides: TowerSide[] = ['north', 'east', 'south', 'west'];\n    const oldIndex = sides.indexOf(oldPosition);\n    const newIndex = sides.indexOf(newPosition);\n\n    // Calculate rotation steps (positive for clockwise)\n    let rotationSteps = newIndex - oldIndex;\n    if (rotationSteps < 0) {\n      rotationSteps += TOWER_SIDES_COUNT; // Handle wrap-around\n    }\n\n    // Only update if there was actually a rotation\n    if (rotationSteps > 0) {\n      this.updateGlyphPositionsAfterRotation(level, rotationSteps);\n    }\n  }\n\n  /**\n   * Updates glyph positions for a specific level rotation.\n   * @param level - The drum level that was rotated\n   * @param newPosition - The new position the drum was rotated to\n   * @deprecated Use calculateAndUpdateGlyphPositions instead\n   */\n  private updateGlyphPositionsForRotation(level: TowerLevels, newPosition: TowerSide): void {\n    // Get the current drum position before rotation\n    const currentPosition = this.getCurrentDrumPosition(level);\n\n    // Calculate rotation steps\n    const sides: TowerSide[] = ['north', 'east', 'south', 'west'];\n    const currentIndex = sides.indexOf(currentPosition);\n    const newIndex = sides.indexOf(newPosition);\n\n    // Calculate rotation steps (positive for clockwise)\n    let rotationSteps = newIndex - currentIndex;\n    if (rotationSteps < 0) {\n      rotationSteps += TOWER_SIDES_COUNT; // Handle wrap-around\n    }\n\n    // Update glyph positions\n    this.updateGlyphPositionsAfterRotation(level, rotationSteps);\n  }\n\n  /**\n   * Checks if a specific seal is broken.\n   * @param seal - The seal identifier to check\n   * @returns True if the seal is broken, false otherwise\n   */\n  isSealBroken(seal: SealIdentifier): boolean {\n    const sealKey = `${seal.level}-${seal.side}`;\n    return this.brokenSeals.has(sealKey);\n  }\n\n  /**\n   * Gets a list of all broken seals.\n   * @returns Array of SealIdentifier objects representing all broken seals\n   */\n  getBrokenSeals(): SealIdentifier[] {\n    return Array.from(this.brokenSeals).map(sealKey => {\n      const [level, side] = sealKey.split('-');\n      return { level: level as TowerLevels, side: side as TowerSide };\n    });\n  }\n\n  /**\n   * Resets the broken seals tracking (clears all broken seals).\n   */\n  resetBrokenSeals(): void {\n    this.brokenSeals.clear();\n  }\n\n  /**\n   * Gets a random unbroken seal that can be passed to breakSeal().\n   * @returns A random SealIdentifier that is not currently broken, or null if all seals are broken\n   */\n  getRandomUnbrokenSeal(): SealIdentifier | null {\n    const allSeals: SealIdentifier[] = [];\n    const levels: TowerLevels[] = ['top', 'middle', 'bottom'];\n    const sides: TowerSide[] = ['north', 'east', 'south', 'west'];\n\n    // Generate all possible seal combinations\n    for (const level of levels) {\n      for (const side of sides) {\n        allSeals.push({ level, side });\n      }\n    }\n\n    // Filter out broken seals\n    const unbrokenSeals = allSeals.filter(seal => !this.isSealBroken(seal));\n\n    if (unbrokenSeals.length === 0) {\n      return null; // All seals are broken\n    }\n\n    // Return a random unbroken seal\n    const randomIndex = Math.floor(Math.random() * unbrokenSeals.length);\n    return unbrokenSeals[randomIndex];\n  }\n\n  //#region bluetooth\n\n  /**\n   * Establishes a Bluetooth connection to the Dark Tower device.\n   * Initializes GATT services, characteristics, and starts connection monitoring.\n   * @returns {Promise<void>} Promise that resolves when connection is established\n   */\n  async connect() {\n    await this.bleConnection.connect();\n  }\n\n  /**\n   * Disconnects from the tower device and cleans up resources.\n   * @returns {Promise<void>} Promise that resolves when disconnection is complete\n   */\n  async disconnect() {\n    await this.bleConnection.disconnect();\n  }\n\n  //#endregion\n\n  //#region utility\n\n  /**\n   * Configure logger outputs for this UltimateDarkTower instance\n   * @param {LogOutput[]} outputs - Array of log outputs to use (e.g., ConsoleOutput, DOMOutput)\n   */\n  setLoggerOutputs(outputs: LogOutput[]) {\n    // Clear existing outputs and add new ones to maintain logger instance references\n    (this.logger as any).outputs = [];\n    outputs.forEach(output => this.logger.addOutput(output));\n  }\n\n  /**\n   * Sends a command packet to the tower via Bluetooth with error handling and retry logic.\n   * @param {Uint8Array} command - The command packet to send to the tower\n   * @returns {Promise<void>} Promise that resolves when command is sent successfully\n   */\n  async sendTowerCommand(command: Uint8Array) {\n    return await this.towerCommands.sendTowerCommand(command);\n  }\n\n  /**\n   * Converts a command packet to a hex string representation for debugging.\n   * @param {Uint8Array} command - Command packet to convert\n   * @returns {string} Hex string representation of the command packet\n   */\n  commandToPacketString(command: Uint8Array): string {\n    return commandToPacketString(command);\n  }\n\n  /**\n   * Converts battery voltage in millivolts to percentage.\n   * @param {number} mv - Battery voltage in millivolts\n   * @returns {string} Battery percentage as formatted string (e.g., \"75%\")\n   */\n  milliVoltsToPercentage(mv: number): string {\n    return milliVoltsToPercentage(mv);\n  }\n\n  //#endregion\n\n  //#region Connection Management\n\n  /**\n   * Enable or disable connection monitoring\n   * @param {boolean} enabled - Whether to enable connection monitoring\n   */\n  setConnectionMonitoring(enabled: boolean) {\n    this.bleConnection.setConnectionMonitoring(enabled);\n  }\n\n  /**\n   * Configure connection monitoring parameters\n   * @param {number} [frequency=2000] - How often to check connection (milliseconds)\n   * @param {number} [timeout=30000] - How long to wait for responses before considering connection lost (milliseconds)\n   */\n  configureConnectionMonitoring(frequency: number = DEFAULT_CONNECTION_MONITORING_FREQUENCY, timeout: number = DEFAULT_CONNECTION_MONITORING_TIMEOUT) {\n    this.bleConnection.configureConnectionMonitoring(frequency, timeout);\n  }\n\n  /**\n   * Configure battery heartbeat monitoring parameters\n   * Tower sends battery status every ~200ms, so this is the most reliable disconnect indicator\n   * @param {boolean} [enabled=true] - Whether to enable battery heartbeat monitoring\n   * @param {number} [timeout=3000] - How long to wait for battery status before considering disconnected (milliseconds)\n   * @param {boolean} [verifyConnection=true] - Whether to verify connection status before triggering disconnection on heartbeat timeout\n   */\n  configureBatteryHeartbeatMonitoring(enabled: boolean = true, timeout: number = DEFAULT_BATTERY_HEARTBEAT_TIMEOUT, verifyConnection: boolean = true) {\n    this.bleConnection.configureBatteryHeartbeatMonitoring(enabled, timeout, verifyConnection);\n  }\n\n  /**\n   * Check if the tower is currently connected\n   * @returns {Promise<boolean>} True if connected and responsive\n   */\n  async isConnectedAndResponsive(): Promise<boolean> {\n    return await this.bleConnection.isConnectedAndResponsive();\n  }\n\n  /**\n   * Get detailed connection status including heartbeat information\n   * @returns {Object} Object with connection details\n   */\n  getConnectionStatus(): ConnectionStatus {\n    return this.bleConnection.getConnectionStatus();\n  }\n  //#endregion\n\n\n  //#region cleanup\n\n  /**\n   * Clean up resources and disconnect properly\n   * @returns {Promise<void>} Promise that resolves when cleanup is complete\n   */\n  async cleanup() {\n    this.logger.info('Cleaning up UltimateDarkTower instance', '[UDT]');\n    // Clear any pending commands in the queue\n    this.towerCommands.clearQueue();\n    await this.bleConnection.cleanup();\n  }\n\n  //#endregion\n}\n\nexport default UltimateDarkTower;\n", "import { VOLTAGE_LEVELS, LED_CHANNEL_LOOKUP } from './udtConstants';\nimport { type TowerState } from './udtTowerState';\n\n/**\n * Internal function to calculate battery percentage from millivolts.\n * @param mv - Battery voltage in millivolts\n * @returns Battery percentage as number (0-100)\n */\nfunction calculateBatteryPercentage(mv: number): number {\n  const batLevel = mv ? mv / 3 : 0; // lookup is based on single AA\n  const levels = VOLTAGE_LEVELS.filter(v => batLevel >= v);\n  return levels.length * 5;\n}\n\n/**\n * Converts battery voltage in millivolts to percentage number (0-100).\n * @param mv - Battery voltage in millivolts\n * @returns Battery percentage as number (0-100)\n */\nexport function milliVoltsToPercentageNumber(mv: number): number {\n  return calculateBatteryPercentage(mv);\n}\n\n/**\n * Converts battery voltage in millivolts to percentage.\n * Tower returns sum total battery level in millivolts for all batteries.\n * @param mv - Battery voltage in millivolts\n * @returns Battery percentage as formatted string (e.g., \"75%\")\n */\nexport function milliVoltsToPercentage(mv: number): string {\n  return `${calculateBatteryPercentage(mv)}%`;\n}\n\n/**\n * Extracts battery voltage in millivolts from a tower battery response.\n * @param {Uint8Array} command - Battery response packet from tower\n * @returns {number} Battery voltage in millivolts\n */\nexport function getMilliVoltsFromTowerResponse(command: Uint8Array): number {\n  const mv = new Uint8Array(4);\n  mv[0] = command[4];\n  mv[1] = command[3];\n  mv[2] = 0;\n  mv[3] = 0;\n  const view = new DataView(mv.buffer, 0);\n  return view.getUint32(0, true);\n}\n\n/**\n * Converts a command packet to a hex string representation for debugging.\n * @param {Uint8Array} command - Command packet to convert\n * @returns {string} Hex string representation of the command packet\n */\nexport function commandToPacketString(command: Uint8Array): string {\n  if (command.length === 0) {\n    return \"[]\";\n  }\n  let cmdStr = \"[\";\n  command.forEach(n => cmdStr += n.toString(16) + \",\");\n  cmdStr = cmdStr.slice(0, -1) + \"]\";\n  return cmdStr;\n}\n\n/**\n * Utility function to get the tower position and direction for a given layer and light index\n * Updated based on LED channel lookup table and corrected architecture:\n * - Layers 0-2: Ring LEDs with cardinal directions (N,E,S,W)\n * - Layers 3-5: Ledge/Base LEDs with ordinal directions (NE,SE,SW,NW)\n * @param layerIndex - The layer index (0-5)\n * @param lightIndex - The light index within the layer (0-3)\n * @returns Object containing the tower level, direction, and LED channel\n */\nexport function getTowerPosition(layerIndex: number, lightIndex: number): { level: string, direction: string, ledChannel?: number } {\n  const isRingLayer = layerIndex <= 2;\n  const ledChannel = LED_CHANNEL_LOOKUP[layerIndex * 4 + lightIndex];\n\n  if (isRingLayer) {\n    // Ring layers: cardinal directions (position 0 = North)\n    const directions = ['NORTH', 'EAST', 'SOUTH', 'WEST'];\n    const layerNames = ['TOP_RING', 'MIDDLE_RING', 'BOTTOM_RING'];\n    return {\n      level: layerNames[layerIndex],\n      direction: directions[lightIndex],\n      ledChannel\n    };\n  } else {\n    // Ledge/Base layers: ordinal directions (position 0 = North-East)\n    const directions = ['NORTH_EAST', 'SOUTH_EAST', 'SOUTH_WEST', 'NORTH_WEST'];\n    const layerNames = ['LEDGE', 'BASE1', 'BASE2'];\n    return {\n      level: layerNames[layerIndex - 3],\n      direction: directions[lightIndex],\n      ledChannel\n    };\n  }\n}\n\n/**\n * Utility function to get all active lights in a tower state\n * @param state - The tower state object\n * @returns Array of objects describing each active light\n */\nexport function getActiveLights(state: TowerState): Array<{ level: string, direction: string, effect: number, loop: boolean }> {\n  const activeLights: Array<{ level: string, direction: string, effect: number, loop: boolean }> = [];\n\n  state.layer.forEach((layer, layerIndex) => {\n    layer.light.forEach((light, lightIndex) => {\n      if (light.effect > 0) {\n        const position = getTowerPosition(layerIndex, lightIndex);\n        activeLights.push({\n          level: position.level,\n          direction: position.direction,\n          effect: light.effect,\n          loop: light.loop\n        });\n      }\n    });\n  });\n\n  return activeLights;\n}\n\n/**\n * Creates a default/empty tower state with all settings reset to defaults\n * @returns A default TowerState object with all lights off, no audio, etc.\n */\nexport function createDefaultTowerState(): TowerState {\n  return {\n    drum: [\n      { jammed: false, calibrated: false, position: 0, playSound: false, reverse: false },\n      { jammed: false, calibrated: false, position: 0, playSound: false, reverse: false },\n      { jammed: false, calibrated: false, position: 0, playSound: false, reverse: false }\n    ],\n    layer: [\n      { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] },\n      { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] },\n      { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] },\n      { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] },\n      { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] },\n      { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] }\n    ],\n    audio: { sample: 0, loop: false, volume: 0 },\n    beam: { count: 0, fault: false },\n    led_sequence: 0\n  };\n}", "import type { TowerState } from './udtTowerState';\n\nexport type LogLevel = 'all' | 'debug' | 'info' | 'warn' | 'error';\n\nexport interface LogOutput {\n    write(level: LogLevel, message: string, timestamp: Date): void;\n}\n\nexport class ConsoleOutput implements LogOutput {\n    write(level: LogLevel, message: string): void {\n        switch (level) {\n            case 'debug':\n                console.debug(message);\n                break;\n            case 'info':\n                console.info(message);\n                break;\n            case 'warn':\n                console.warn(message);\n                break;\n            case 'error':\n                console.error(message);\n                break;\n        }\n    }\n}\n\nexport interface LogEntry {\n    level: LogLevel;\n    message: string;\n    timestamp: Date;\n}\n\nexport class BufferOutput implements LogOutput {\n    private buffer: LogEntry[] = [];\n    private maxEntries: number = 1000;\n    private clearCount: number = 100;\n\n    constructor(maxEntries: number = 1000, clearCount: number = 100) {\n        this.maxEntries = maxEntries;\n        this.clearCount = clearCount;\n    }\n\n    write(level: LogLevel, message: string, timestamp: Date): void {\n        this.buffer.push({ level, message, timestamp });\n\n        // When buffer exceeds max capacity, remove first clearCount entries\n        if (this.buffer.length > this.maxEntries) {\n            this.buffer.splice(0, this.clearCount);\n        }\n    }\n\n    getBuffer(): LogEntry[] {\n        return [...this.buffer];\n    }\n\n    getBufferSize(): number {\n        return this.buffer.length;\n    }\n\n    clearBuffer(): void {\n        this.buffer = [];\n    }\n\n    getEntriesByLevel(level: LogLevel): LogEntry[] {\n        return this.buffer.filter(entry => entry.level === level);\n    }\n\n    getEntriesSince(timestamp: Date): LogEntry[] {\n        return this.buffer.filter(entry => entry.timestamp >= timestamp);\n    }\n}\n\nexport class DOMOutput implements LogOutput {\n    private container: HTMLElement | null = null;\n    private maxLines: number = 100;\n    private allEntries: Array<{ level: LogLevel; message: string; timestamp: Date }> = [];\n\n    constructor(containerId: string, maxLines: number = 100) {\n        this.container = typeof document !== 'undefined' ? document.getElementById(containerId) : null;\n        this.maxLines = maxLines;\n    }\n\n    write(level: LogLevel, message: string, timestamp: Date): void {\n        if (!this.container) return;\n\n        // Store the entry data (not DOM elements) for filtering\n        this.allEntries.push({ level, message, timestamp });\n\n        // Remove oldest entries if we exceed maxLines\n        while (this.allEntries.length > this.maxLines) {\n            this.allEntries.shift();\n        }\n\n        // Refresh the display with current filtering\n        this.refreshDisplay();\n    }\n\n    private refreshDisplay(): void {\n        if (!this.container) return;\n\n        // Clear current display\n        this.container.innerHTML = '';\n\n        // Get currently enabled levels from checkboxes\n        const enabledLevels = this.getEnabledLevelsFromCheckboxes();\n\n        // Get text filter value\n        const textFilter = this.getTextFilter();\n\n        // Add entries that match the current filter\n        this.allEntries.forEach(entry => {\n            // Only show entries if their level checkbox is checked\n            if (enabledLevels.has(entry.level)) {\n                // Apply text filter if one is set\n                if (textFilter && !entry.message.toLowerCase().includes(textFilter.toLowerCase())) {\n                    return; // Skip this entry if it doesn't match text filter\n                }\n\n                // Create fresh DOM element for this entry\n                const timeStr = entry.timestamp.toLocaleTimeString();\n                const logLine = document.createElement('div');\n                logLine.className = `log-line log-${entry.level}`;\n                logLine.textContent = `[${timeStr}] ${entry.message}`;\n\n                this.container!.appendChild(logLine);\n            }\n        });\n\n        // Auto-scroll to bottom\n        this.container.scrollTop = this.container.scrollHeight;\n\n        // Update buffer size display\n        this.updateBufferSizeDisplay();\n    }\n\n    private getEnabledLevelsFromCheckboxes(): Set<LogLevel> {\n        const enabledLevels = new Set<LogLevel>();\n\n        if (typeof document === 'undefined') {\n            return enabledLevels;\n        }\n\n        // Check for checkboxes with pattern logLevel-{level}\n        const checkboxes = ['debug', 'info', 'warn', 'error'];\n        checkboxes.forEach(level => {\n            const checkbox = document.getElementById(`logLevel-${level}`) as HTMLInputElement;\n            if (checkbox && checkbox.checked) {\n                enabledLevels.add(level as LogLevel);\n            }\n        });\n\n        return enabledLevels;\n    }\n\n    private getTextFilter(): string {\n        if (typeof document === 'undefined') {\n            return '';\n        }\n\n        const textFilterInput = document.getElementById('logTextFilter') as HTMLInputElement;\n        return textFilterInput?.value?.trim() || '';\n    }\n\n    private updateBufferSizeDisplay(): void {\n        if (typeof document === 'undefined') {\n            return;\n        }\n\n        const bufferSizeElement = document.getElementById('logBufferSize');\n        if (!bufferSizeElement) {\n            return;\n        }\n\n        // Count currently displayed entries\n        const displayedCount = this.container?.children?.length || 0;\n\n        // Total entries in buffer\n        const totalCount = this.allEntries.length;\n\n        // Update display\n        bufferSizeElement.textContent = `${displayedCount} / ${totalCount}`;\n    }\n\n    // Public method to refresh display when filter checkboxes change\n    public refreshFilter(): void {\n        this.refreshDisplay();\n    }\n\n    // Public method to clear all entries\n    public clearAll(): void {\n        this.allEntries = [];\n        if (this.container) {\n            this.container.innerHTML = '';\n        }\n        // Update buffer size display to show 0/0\n        this.updateBufferSizeDisplay();\n    }\n\n    // Debug methods to help diagnose filtering issues\n    public getEntryCount(): number {\n        return this.allEntries.length;\n    }\n\n    public getEnabledLevels(): string[] {\n        return Array.from(this.getEnabledLevelsFromCheckboxes());\n    }\n\n    public debugEntries(): void {\n        console.log('DOMOutput Debug:');\n        console.log('- Container exists:', !!this.container);\n        console.log('- Entry count:', this.allEntries.length);\n        console.log('- Enabled levels:', this.getEnabledLevels());\n        console.log('- Entries:', this.allEntries);\n    }\n}\n\nexport class Logger {\n    private outputs: LogOutput[] = [];\n    private enabledLevels: Set<LogLevel> = new Set(['all']);\n    private static instance: Logger | null = null;\n\n    constructor() {\n        // Default to console output\n        this.outputs.push(new ConsoleOutput());\n    }\n\n    static getInstance(): Logger {\n        if (!Logger.instance) {\n            Logger.instance = new Logger();\n        }\n        return Logger.instance;\n    }\n\n    addOutput(output: LogOutput): void {\n        this.outputs.push(output);\n    }\n\n    setMinLevel(level: LogLevel): void {\n        this.enabledLevels = new Set([level]);\n    }\n\n    setEnabledLevels(levels: LogLevel[]): void {\n        this.enabledLevels = new Set(levels);\n    }\n\n    enableLevel(level: LogLevel): void {\n        this.enabledLevels.add(level);\n    }\n\n    disableLevel(level: LogLevel): void {\n        this.enabledLevels.delete(level);\n    }\n\n    getEnabledLevels(): LogLevel[] {\n        return Array.from(this.enabledLevels);\n    }\n\n    private shouldLog(level: LogLevel): boolean {\n        if (this.enabledLevels.has('all')) return true;\n        if (level === 'all') return true;\n\n        // If 'all' is not enabled, check if this specific level is enabled\n        if (this.enabledLevels.has(level)) return true;\n\n        // Legacy support: if only one level is enabled and it's not 'all',\n        // treat it as a minimum level threshold\n        if (this.enabledLevels.size === 1) {\n            const singleLevel = Array.from(this.enabledLevels)[0];\n            if (singleLevel !== 'all') {\n                const levels: LogLevel[] = ['debug', 'info', 'warn', 'error'];\n                const minIndex = levels.indexOf(singleLevel);\n                const currentIndex = levels.indexOf(level);\n                return currentIndex >= minIndex;\n            }\n        }\n\n        return false;\n    }\n\n    private log(level: LogLevel, message: string, context?: string): void {\n        if (!this.shouldLog(level)) return;\n\n        const contextPrefix = context ? `${context} ` : '';\n        const finalMessage = `${contextPrefix}${message}`;\n        const timestamp = new Date();\n        this.outputs.forEach(output => {\n            try {\n                output.write(level, finalMessage, timestamp);\n            } catch (error) {\n                console.error('Logger output error:', error);\n            }\n        });\n    }\n\n    debug(message: string, context?: string): void {\n        this.log('debug', message, context);\n    }\n\n    info(message: string, context?: string): void {\n        this.log('info', message, context);\n    }\n\n    warn(message: string, context?: string): void {\n        this.log('warn', message, context);\n    }\n\n    error(message: string, context?: string): void {\n        this.log('error', message, context);\n    }\n\n    /**\n     * Logs tower state changes with detailed information about what changed.\n     * @param oldState - The previous tower state\n     * @param newState - The new tower state\n     * @param source - Source identifier for the update (e.g., \"sendTowerState\", \"tower response\")\n     * @param enableDetailedLogging - Whether to include detailed change descriptions\n     */\n    logTowerStateChange(oldState: TowerState, newState: TowerState, source: string, enableDetailedLogging: boolean = false): void {\n        this.info(`Tower state updated from ${source}`, '[UDT]');\n\n        if (enableDetailedLogging) {\n            const changes = this.computeStateChanges(oldState, newState);\n            if (changes.length > 0) {\n                this.info(`State changes: ${changes.join(', ')}`, '[UDT]');\n            } else {\n                this.info('No changes detected in state update', '[UDT]');\n            }\n        }\n    }\n\n    /**\n     * Computes the differences between two tower states for logging purposes.\n     * @param oldState - The previous tower state\n     * @param newState - The new tower state\n     * @returns Array of human-readable change descriptions\n     */\n    private computeStateChanges(oldState: TowerState, newState: TowerState): string[] {\n        const changes: string[] = [];\n\n        // Check drum changes\n        for (let i = 0; i < 3; i++) {\n            const drumNames = ['top', 'middle', 'bottom'];\n            const oldDrum = oldState.drum[i];\n            const newDrum = newState.drum[i];\n\n            if (oldDrum.position !== newDrum.position) {\n                const positions = ['north', 'east', 'south', 'west'];\n                changes.push(`${drumNames[i]} drum: ${positions[oldDrum.position]} \u2192 ${positions[newDrum.position]}`);\n            }\n            if (oldDrum.calibrated !== newDrum.calibrated) {\n                changes.push(`${drumNames[i]} drum calibrated: ${oldDrum.calibrated} \u2192 ${newDrum.calibrated}`);\n            }\n            if (oldDrum.jammed !== newDrum.jammed) {\n                changes.push(`${drumNames[i]} drum jammed: ${oldDrum.jammed} \u2192 ${newDrum.jammed}`);\n            }\n            if (oldDrum.playSound !== newDrum.playSound) {\n                changes.push(`${drumNames[i]} drum playSound: ${oldDrum.playSound} \u2192 ${newDrum.playSound}`);\n            }\n        }\n\n        // Check LED layer changes\n        const layerNames = ['top ring', 'middle ring', 'bottom ring', 'ledge', 'base1', 'base2'];\n        for (let layerIndex = 0; layerIndex < 6; layerIndex++) {\n            for (let lightIndex = 0; lightIndex < 4; lightIndex++) {\n                const oldLight = oldState.layer[layerIndex].light[lightIndex];\n                const newLight = newState.layer[layerIndex].light[lightIndex];\n\n                const lightChanges: string[] = [];\n                if (oldLight.effect !== newLight.effect) {\n                    lightChanges.push(`effect ${oldLight.effect} \u2192 ${newLight.effect}`);\n                }\n                if (oldLight.loop !== newLight.loop) {\n                    lightChanges.push(`loop ${oldLight.loop} \u2192 ${newLight.loop}`);\n                }\n\n                if (lightChanges.length > 0) {\n                    changes.push(`${layerNames[layerIndex]} light ${lightIndex}: ${lightChanges.join(', ')}`);\n                }\n            }\n        }\n\n        // Check audio changes\n        if (oldState.audio.sample !== newState.audio.sample) {\n            changes.push(`audio sample: ${oldState.audio.sample} \u2192 ${newState.audio.sample}`);\n        }\n        if (oldState.audio.loop !== newState.audio.loop) {\n            changes.push(`audio loop: ${oldState.audio.loop} \u2192 ${newState.audio.loop}`);\n        }\n        if (oldState.audio.volume !== newState.audio.volume) {\n            changes.push(`audio volume: ${oldState.audio.volume} \u2192 ${newState.audio.volume}`);\n        }\n\n        // Check beam changes\n        if (oldState.beam.count !== newState.beam.count) {\n            changes.push(`beam count: ${oldState.beam.count} \u2192 ${newState.beam.count}`);\n        }\n        if (oldState.beam.fault !== newState.beam.fault) {\n            changes.push(`beam fault: ${oldState.beam.fault} \u2192 ${newState.beam.fault}`);\n        }\n\n        // Check LED sequence changes\n        if (oldState.led_sequence !== newState.led_sequence) {\n            changes.push(`LED sequence: ${oldState.led_sequence} \u2192 ${newState.led_sequence}`);\n        }\n\n        return changes;\n    }\n}\n\n// Export singleton instance for easy use\nexport const logger = Logger.getInstance();", "import {\n    TOWER_DEVICE_NAME,\n    UART_SERVICE_UUID,\n    UART_TX_CHARACTERISTIC_UUID,\n    UART_RX_CHARACTERISTIC_UUID,\n    SKULL_DROP_COUNT_POS,\n    DIS_SERVICE_UUID,\n    DIS_MANUFACTURER_NAME_UUID,\n    DIS_MODEL_NUMBER_UUID,\n    DIS_SERIAL_NUMBER_UUID,\n    DIS_HARDWARE_REVISION_UUID,\n    DIS_FIRMWARE_REVISION_UUID,\n    DIS_SOFTWARE_REVISION_UUID,\n    DIS_SYSTEM_ID_UUID,\n    DIS_IEEE_REGULATORY_UUID,\n    DIS_PNP_ID_UUID,\n} from './udtConstants';\nimport { Logger } from './udtLogger';\nimport { TowerResponseProcessor } from './udtTowerResponse';\nimport { getMilliVoltsFromTowerResponse, milliVoltsToPercentage } from './udtHelpers';\nimport { rtdt_unpack_state } from './udtTowerState'\n\n\nexport interface TowerEventCallbacks {\n    onTowerConnect: () => void;\n    onTowerDisconnect: () => void;\n    onBatteryLevelNotify: (millivolts: number) => void;\n    onCalibrationComplete: () => void;\n    onSkullDrop: (towerSkullCount: number) => void;\n    onTowerResponse?: (response: Uint8Array) => void; // Optional callback for command queue response detection with response data\n}\n\nexport interface DeviceInformation {\n    manufacturerName?: string;\n    modelNumber?: string;\n    serialNumber?: string;\n    hardwareRevision?: string;\n    firmwareRevision?: string;\n    softwareRevision?: string;\n    systemId?: string;\n    ieeeRegulatory?: string;\n    pnpId?: string;\n    lastUpdated?: Date;\n}\n\nexport interface ConnectionStatus {\n    isConnected: boolean;\n    isGattConnected: boolean;\n    lastBatteryHeartbeatMs: number;\n    lastCommandResponseMs: number;\n    batteryHeartbeatHealthy: boolean;\n    connectionMonitoringEnabled: boolean;\n    batteryHeartbeatMonitoringEnabled: boolean;\n    batteryHeartbeatTimeoutMs: number;\n    batteryHeartbeatVerifyConnection: boolean;\n    connectionTimeoutMs: number;\n}\n\nexport class UdtBleConnection {\n    private logger: Logger;\n    private callbacks: TowerEventCallbacks;\n    private responseProcessor: TowerResponseProcessor;\n\n    // BLE connection objects\n    TowerDevice = null;\n    txCharacteristic = null;\n    rxCharacteristic = null;\n\n    // Connection state\n    isConnected: boolean = false;\n    performingCalibration: boolean = false;\n    performingLongCommand: boolean = false;\n\n    // Connection monitoring\n    private connectionMonitorInterval: ReturnType<typeof setInterval> | null = null;\n    connectionMonitorFrequency: number = 2 * 1000;\n    lastSuccessfulCommand: number = 0;\n    connectionTimeoutThreshold: number = 30 * 1000;\n    enableConnectionMonitoring: boolean = true;\n\n    // Battery heartbeat monitoring\n    lastBatteryHeartbeat: number = 0;\n    batteryHeartbeatTimeout: number = 3 * 1000;\n    longTowerCommandTimeout: number = 30 * 1000;\n    enableBatteryHeartbeatMonitoring: boolean = true;\n    batteryHeartbeatVerifyConnection: boolean = true; // When true, verifies connection before triggering disconnection on heartbeat timeout\n\n    // Tower state\n    towerSkullDropCount: number = -1;\n    lastBatteryNotification: number = 0;\n    lastBatteryPercentage: string = \"\";\n    batteryNotifyFrequency: number = 15 * 1000;\n    batteryNotifyOnValueChangeOnly = false;\n    batteryNotifyEnabled = true;\n\n    // Device information\n    private deviceInformation: DeviceInformation = {};\n\n    // Logging configuration\n    logTowerResponses = true;\n    logTowerResponseConfig = {\n        TOWER_STATE: true,\n        INVALID_STATE: true,\n        HARDWARE_FAILURE: true,\n        MECH_JIGGLE_TRIGGERED: true,\n        MECH_UNEXPECTED_TRIGGER: true,\n        MECH_DURATION: true,\n        DIFFERENTIAL_READINGS: false,\n        BATTERY_READING: true,\n        CALIBRATION_FINISHED: true,\n        LOG_ALL: false,\n    };\n\n    constructor(logger: Logger, callbacks: TowerEventCallbacks) {\n        this.logger = logger;\n        this.callbacks = callbacks;\n        this.responseProcessor = new TowerResponseProcessor();\n    }\n\n    async connect() {\n        this.logger.info(\"Looking for Tower...\", '[UDT]');\n        try {\n            // @ts-ignore\n            this.TowerDevice = await navigator.bluetooth.requestDevice({\n                filters: [{ namePrefix: TOWER_DEVICE_NAME }],\n                optionalServices: [UART_SERVICE_UUID, DIS_SERVICE_UUID]\n            });\n\n            if (this.TowerDevice === null) {\n                this.logger.warn(\"Tower not found\", '[UDT]');\n                return\n            }\n\n            // @ts-ignore\n            navigator.bluetooth.addEventListener(\"availabilitychanged\", this.bleAvailabilityChange);\n\n            this.logger.info(\"Connecting to Tower GATT Server...\", '[UDT]');\n            const server = await this.TowerDevice.gatt.connect();\n\n            this.logger.info(\"Getting Tower Primary Service...\", '[UDT]');\n            const service = await server.getPrimaryService(UART_SERVICE_UUID);\n\n            this.logger.info(\"Getting Tower Characteristics...\", '[UDT]');\n            this.txCharacteristic = await service.getCharacteristic(\n                UART_TX_CHARACTERISTIC_UUID\n            );\n\n            this.rxCharacteristic = await service.getCharacteristic(\n                UART_RX_CHARACTERISTIC_UUID\n            );\n\n            this.logger.info(\"Subscribing to Tower...\", '[UDT]');\n            await this.rxCharacteristic.startNotifications();\n            await this.rxCharacteristic.addEventListener(\n                \"characteristicvaluechanged\",\n                this.onRxCharacteristicValueChanged\n            );\n\n            this.TowerDevice.addEventListener('gattserverdisconnected', this.onTowerDeviceDisconnected);\n\n            this.logger.info('Tower connection complete', '[UDT][BLE]');\n            this.isConnected = true;\n            this.lastSuccessfulCommand = Date.now();\n            this.lastBatteryHeartbeat = Date.now();\n\n            // Read device information after successful connection\n            await this.readDeviceInformation();\n\n            if (this.enableConnectionMonitoring) {\n                this.startConnectionMonitoring();\n            }\n\n            this.callbacks.onTowerConnect();\n        } catch (error) {\n            this.logger.error(`Tower Connection Error: ${error}`, '[UDT][BLE]');\n            this.isConnected = false;\n            this.callbacks.onTowerDisconnect();\n        }\n    }\n\n    async disconnect() {\n        if (!this.TowerDevice) {\n            return;\n        }\n\n        this.stopConnectionMonitoring();\n\n        if (this.TowerDevice.gatt.connected) {\n            this.TowerDevice.removeEventListener('gattserverdisconnected', this.onTowerDeviceDisconnected);\n            await this.TowerDevice.gatt.disconnect();\n            this.logger.info(\"Tower disconnected\", '[UDT]');\n            this.handleDisconnection();\n        }\n    }\n\n    onRxCharacteristicValueChanged = (event: Event) => {\n        this.lastSuccessfulCommand = Date.now();\n\n        // @ts-ignore-next-line\n        const target = event.target as any;\n        let receivedData = new Uint8Array(target.value.byteLength);\n        for (var i = 0; i < target.value.byteLength; i++) {\n            receivedData[i] = target.value.getUint8(i);\n        }\n        const { cmdKey } = this.responseProcessor.getTowerCommand(receivedData[0]);\n\n        const shouldLogCommand = this.logTowerResponses &&\n            this.responseProcessor.shouldLogResponse(cmdKey, this.logTowerResponseConfig) &&\n            (!this.responseProcessor.isBatteryResponse(cmdKey) || this.batteryNotifyEnabled);\n\n        if (shouldLogCommand) {\n            this.logger.info(`${cmdKey}`, '[UDT][BLE][RCVD]');\n        }\n\n        if (this.logTowerResponses) {\n            this.logTowerResponse(receivedData);\n        }\n\n        if (this.responseProcessor.isTowerStateResponse(cmdKey)) {\n            this.handleTowerStateResponse(receivedData);\n        }\n\n        if (this.responseProcessor.isBatteryResponse(cmdKey)) {\n            this.lastBatteryHeartbeat = Date.now();\n\n            const millivolts = getMilliVoltsFromTowerResponse(receivedData);\n            const batteryPercentage = milliVoltsToPercentage(millivolts);\n            const didBatteryLevelChange = this.lastBatteryPercentage !== \"\" && this.lastBatteryPercentage !== batteryPercentage;\n            const batteryNotifyFrequencyPassed = ((Date.now() - this.lastBatteryNotification) >= this.batteryNotifyFrequency);\n\n            const shouldNotify = this.batteryNotifyEnabled && (this.batteryNotifyOnValueChangeOnly ?\n                (didBatteryLevelChange || this.lastBatteryPercentage === \"\") :\n                batteryNotifyFrequencyPassed);\n\n            if (shouldNotify) {\n                this.logger.info(`${this.responseProcessor.commandToString(receivedData).join(' ')}`, '[UDT][BLE]');\n                this.lastBatteryNotification = Date.now();\n                this.lastBatteryPercentage = batteryPercentage;\n                this.callbacks.onBatteryLevelNotify(millivolts);\n            }\n        } else {\n            // For non-battery responses, notify the command queue\n            // This includes tower state responses, command acknowledgments, etc.\n            if (this.callbacks.onTowerResponse) {\n                this.callbacks.onTowerResponse(receivedData);\n            }\n        }\n    }\n\n    private handleTowerStateResponse(receivedData: Uint8Array) {\n        const dataSkullDropCount = receivedData[SKULL_DROP_COUNT_POS];\n        const state = rtdt_unpack_state(receivedData);\n        this.logger.debug(`Tower State: ${JSON.stringify(state)} `, '[UDT][BLE]');\n\n        if (this.performingCalibration) {\n            this.performingCalibration = false;\n            this.performingLongCommand = false;\n            this.lastBatteryHeartbeat = Date.now();\n            this.callbacks.onCalibrationComplete();\n            this.logger.info('Tower calibration complete', '[UDT]');\n        }\n\n        if (dataSkullDropCount !== this.towerSkullDropCount) {\n            if (dataSkullDropCount) {\n                this.callbacks.onSkullDrop(dataSkullDropCount);\n                this.logger.info(`Skull drop detected: app:${this.towerSkullDropCount < 0 ? 'empty' : this.towerSkullDropCount}  tower:${dataSkullDropCount}`, '[UDT]');\n            } else {\n                this.logger.info(`Skull count reset to ${dataSkullDropCount}`, '[UDT]');\n            }\n            this.towerSkullDropCount = dataSkullDropCount;\n        }\n    }\n\n    private logTowerResponse(receivedData: Uint8Array) {\n        const { cmdKey, command } = this.responseProcessor.getTowerCommand(receivedData[0]);\n\n        if (!this.responseProcessor.shouldLogResponse(cmdKey, this.logTowerResponseConfig)) {\n            return;\n        }\n\n        if (this.responseProcessor.isBatteryResponse(cmdKey)) {\n            return; // logged elsewhere\n        }\n\n        const logMessage = `${this.responseProcessor.commandToString(receivedData).join(' ')}`;\n\n        if (command.critical) {\n            this.logger.error(logMessage, '[UDT][BLE]');\n        } else {\n            this.logger.info(logMessage, '[UDT][BLE]');\n        }\n    }\n\n    bleAvailabilityChange = (event: Event & { value: boolean }) => {\n        this.logger.info('Bluetooth availability changed', '[UDT][BLE]');\n        const availability = event.value;\n\n        if (!availability && this.isConnected) {\n            this.logger.warn('Bluetooth became unavailable - handling disconnection', '[UDT][BLE]');\n            this.handleDisconnection();\n        }\n    }\n\n    onTowerDeviceDisconnected = (event: Event) => {\n        this.logger.warn(`Tower device disconnected unexpectedly: ${event.type}`, '[UDT][BLE]');\n        this.handleDisconnection();\n    }\n\n    private handleDisconnection() {\n        this.isConnected = false;\n        this.performingCalibration = false;\n        this.performingLongCommand = false;\n        this.stopConnectionMonitoring();\n\n        this.lastBatteryHeartbeat = 0;\n        this.lastSuccessfulCommand = 0;\n\n        this.txCharacteristic = null;\n        this.rxCharacteristic = null;\n\n        // Clear device information on disconnect\n        this.deviceInformation = {};\n\n        this.callbacks.onTowerDisconnect();\n    }\n\n    private startConnectionMonitoring() {\n        if (this.connectionMonitorInterval) {\n            clearInterval(this.connectionMonitorInterval);\n        }\n\n        this.connectionMonitorInterval = setInterval(() => {\n            this.checkConnectionHealth();\n        }, this.connectionMonitorFrequency);\n    }\n\n    private stopConnectionMonitoring() {\n        if (this.connectionMonitorInterval) {\n            clearInterval(this.connectionMonitorInterval);\n            this.connectionMonitorInterval = null;\n        }\n    }\n\n    private checkConnectionHealth() {\n        if (!this.isConnected || !this.TowerDevice) {\n            return;\n        }\n\n        if (!this.TowerDevice.gatt.connected) {\n            this.logger.warn('GATT connection lost detected during health check', '[UDT][BLE]');\n            this.handleDisconnection();\n            return;\n        }\n\n        if (this.enableBatteryHeartbeatMonitoring) {\n            const timeSinceLastBatteryHeartbeat = Date.now() - this.lastBatteryHeartbeat;\n            const timeoutThreshold = this.performingLongCommand ? this.longTowerCommandTimeout : this.batteryHeartbeatTimeout;\n\n            if (timeSinceLastBatteryHeartbeat > timeoutThreshold) {\n                const operationContext = this.performingLongCommand ? ' during long command operation' : '';\n                this.logger.warn(`Battery heartbeat timeout detected${operationContext} - no battery status received in ${timeSinceLastBatteryHeartbeat}ms (expected every ~200ms)`, '[UDT][BLE]');\n\n                if (this.performingLongCommand) {\n                    this.logger.info('Ignoring battery heartbeat timeout during long command - this is expected behavior', '[UDT][BLE]');\n                    return;\n                }\n\n                // Before assuming disconnection, verify if the tower is actually still responsive\n                if (this.batteryHeartbeatVerifyConnection) {\n                    this.logger.info('Verifying tower connection status before triggering disconnection...', '[UDT][BLE]');\n\n                    // Check if GATT is still connected and characteristics are available\n                    if (this.TowerDevice?.gatt?.connected && this.rxCharacteristic) {\n                        this.logger.info('GATT connection and characteristics still available - heartbeat timeout may be temporary', '[UDT][BLE]');\n\n                        // Reset the last battery heartbeat to current time to give it another chance\n                        // This prevents repeated false disconnections while the tower is still actually connected\n                        this.lastBatteryHeartbeat = Date.now();\n                        this.logger.info('Reset battery heartbeat timer - will monitor for another timeout period', '[UDT][BLE]');\n                        return;\n                    }\n                }\n\n                this.logger.warn('Tower possibly disconnected due to battery depletion or power loss', '[UDT][BLE]');\n                this.handleDisconnection();\n                return;\n            }\n        }\n\n        const timeSinceLastResponse = Date.now() - this.lastSuccessfulCommand;\n        if (timeSinceLastResponse > this.connectionTimeoutThreshold) {\n            this.logger.warn('General connection timeout detected - no responses received', '[UDT][BLE]');\n            this.handleDisconnection();\n        }\n    }\n\n    setConnectionMonitoring(enabled: boolean) {\n        this.enableConnectionMonitoring = enabled;\n        if (enabled && this.isConnected) {\n            this.startConnectionMonitoring();\n        } else {\n            this.stopConnectionMonitoring();\n        }\n    }\n\n    configureConnectionMonitoring(frequency: number = 2000, timeout: number = 30000) {\n        this.connectionMonitorFrequency = frequency;\n        this.connectionTimeoutThreshold = timeout;\n\n        if (this.enableConnectionMonitoring && this.isConnected) {\n            this.startConnectionMonitoring();\n        }\n    }\n\n    configureBatteryHeartbeatMonitoring(enabled: boolean = true, timeout: number = 3000, verifyConnection: boolean = true) {\n        this.enableBatteryHeartbeatMonitoring = enabled;\n        this.batteryHeartbeatTimeout = timeout;\n        this.batteryHeartbeatVerifyConnection = verifyConnection;\n    }\n\n    async isConnectedAndResponsive(): Promise<boolean> {\n        if (!this.isConnected || !this.TowerDevice?.gatt?.connected) {\n            return false;\n        }\n\n        // Check if characteristics are still available\n        if (!this.txCharacteristic || !this.rxCharacteristic) {\n            return false;\n        }\n\n        // Additional check: verify the GATT service is still accessible\n        try {\n            // This will throw if the service is no longer available\n            if (this.txCharacteristic.service && this.rxCharacteristic.service) {\n                return true;\n            }\n        } catch (error) {\n            this.logger.warn('GATT characteristics or services no longer accessible', '[UDT][BLE]');\n            return false;\n        }\n\n        return true;\n    }\n\n    getConnectionStatus(): ConnectionStatus {\n        const now = Date.now();\n        const timeSinceLastBattery = this.lastBatteryHeartbeat ? now - this.lastBatteryHeartbeat : -1;\n        const timeSinceLastCommand = this.lastSuccessfulCommand ? now - this.lastSuccessfulCommand : -1;\n\n        return {\n            isConnected: this.isConnected,\n            isGattConnected: this.TowerDevice?.gatt?.connected || false,\n            lastBatteryHeartbeatMs: timeSinceLastBattery,\n            lastCommandResponseMs: timeSinceLastCommand,\n            batteryHeartbeatHealthy: timeSinceLastBattery >= 0 && timeSinceLastBattery < this.batteryHeartbeatTimeout,\n            connectionMonitoringEnabled: this.enableConnectionMonitoring,\n            batteryHeartbeatMonitoringEnabled: this.enableBatteryHeartbeatMonitoring,\n            batteryHeartbeatTimeoutMs: this.batteryHeartbeatTimeout,\n            batteryHeartbeatVerifyConnection: this.batteryHeartbeatVerifyConnection,\n            connectionTimeoutMs: this.connectionTimeoutThreshold\n        };\n    }\n\n    getDeviceInformation(): DeviceInformation {\n        return { ...this.deviceInformation };\n    }\n\n    private async readDeviceInformation() {\n        if (!this.TowerDevice?.gatt?.connected) {\n            this.logger.warn('Cannot read device information - not connected', '[UDT][BLE]');\n            return;\n        }\n\n        try {\n            this.logger.info('Reading device information service...', '[UDT][BLE]');\n            const disService = await this.TowerDevice.gatt.getPrimaryService(DIS_SERVICE_UUID);\n\n            // Reset device information object\n            this.deviceInformation = {};\n\n            const characteristicMap = [\n                { uuid: DIS_MANUFACTURER_NAME_UUID, name: 'Manufacturer Name', key: 'manufacturerName', logIfMissing: true },\n                { uuid: DIS_MODEL_NUMBER_UUID, name: 'Model Number', key: 'modelNumber', logIfMissing: true },\n                { uuid: DIS_SERIAL_NUMBER_UUID, name: 'Serial Number', key: 'serialNumber', logIfMissing: false },\n                { uuid: DIS_HARDWARE_REVISION_UUID, name: 'Hardware Revision', key: 'hardwareRevision', logIfMissing: true },\n                { uuid: DIS_FIRMWARE_REVISION_UUID, name: 'Firmware Revision', key: 'firmwareRevision', logIfMissing: true },\n                { uuid: DIS_SOFTWARE_REVISION_UUID, name: 'Software Revision', key: 'softwareRevision', logIfMissing: true },\n                { uuid: DIS_SYSTEM_ID_UUID, name: 'System ID', key: 'systemId', logIfMissing: false },\n                { uuid: DIS_IEEE_REGULATORY_UUID, name: 'IEEE Regulatory', key: 'ieeeRegulatory', logIfMissing: false },\n                { uuid: DIS_PNP_ID_UUID, name: 'PnP ID', key: 'pnpId', logIfMissing: false },\n            ];\n\n            for (const { uuid, name, key, logIfMissing } of characteristicMap) {\n                try {\n                    const characteristic = await disService.getCharacteristic(uuid);\n                    const value = await characteristic.readValue();\n\n                    if (uuid === DIS_SYSTEM_ID_UUID || uuid === DIS_PNP_ID_UUID) {\n                        // These are binary data, convert to hex string\n                        const hexValue = Array.from(new Uint8Array(value.buffer))\n                            .map(b => b.toString(16).padStart(2, '0'))\n                            .join(':');\n                        this.logger.info(`Device ${name}: ${hexValue}`, '[UDT][BLE]');\n                        (this.deviceInformation as any)[key] = hexValue;\n                    } else {\n                        // Text characteristics\n                        const textValue = new TextDecoder().decode(value);\n                        this.logger.info(`Device ${name}: ${textValue}`, '[UDT][BLE]');\n                        (this.deviceInformation as any)[key] = textValue;\n                    }\n                } catch (error) {\n                    if (logIfMissing) {\n                        this.logger.debug(`Device ${name} characteristic not available`, '[UDT][BLE]');\n                    }\n                }\n            }\n\n            // Set timestamp when device information was last read\n            this.deviceInformation.lastUpdated = new Date();\n        } catch (error) {\n            this.logger.debug('Device Information Service not available', '[UDT][BLE]');\n        }\n    }\n\n    async cleanup() {\n        this.logger.info('Cleaning up UdtBleConnection instance', '[UDT][BLE]');\n\n        this.stopConnectionMonitoring();\n\n        if (this.TowerDevice) {\n            this.TowerDevice.removeEventListener('gattserverdisconnected', this.onTowerDeviceDisconnected);\n        }\n\n        // @ts-ignore\n        if (navigator.bluetooth) {\n            // @ts-ignore\n            navigator.bluetooth.removeEventListener(\"availabilitychanged\", this.bleAvailabilityChange);\n        }\n\n        if (this.isConnected) {\n            await this.disconnect();\n        }\n    }\n\n}", "import {\n    TC,\n    TOWER_MESSAGES\n} from './udtConstants';\nimport { logger } from './udtLogger';\nimport { milliVoltsToPercentage, getMilliVoltsFromTowerResponse, commandToPacketString } from './udtHelpers';\n\nexport class TowerResponseProcessor {\n    private logDetail: boolean = false;\n\n    constructor(logDetail: boolean = false) {\n        this.logDetail = logDetail;\n    }\n\n    /**\n     * Sets whether to include detailed information in command string conversion\n     * @param {boolean} enabled - Whether to enable detailed logging\n     */\n    setDetailedLogging(enabled: boolean) {\n        this.logDetail = enabled;\n    }\n\n    /**\n     * Maps a command value to its corresponding tower message definition.\n     * @param {number} cmdValue - Command value received from tower\n     * @returns {Object} Object containing command key and command definition\n     */\n    getTowerCommand(cmdValue: number) {\n        const cmdKeys = Object.keys(TOWER_MESSAGES);\n        const cmdKey = cmdKeys.find(key => TOWER_MESSAGES[key].value === cmdValue);\n        if (!cmdKey) {\n            logger.warn(`Unknown command received from tower: ${cmdValue} (0x${cmdValue.toString(16)})`, 'TowerResponseProcessor');\n            return { cmdKey: undefined, command: { name: \"Unknown Command\", value: cmdValue } };\n        }\n        const command = TOWER_MESSAGES[cmdKey];\n        return { cmdKey, command };\n    }\n\n    /**\n     * Converts a command packet to a human-readable string array for logging.\n     * @param {Uint8Array} command - Command packet to convert\n     * @returns {Array<string>} Human-readable representation of the command\n     */\n    commandToString(command: Uint8Array): Array<string> {\n        const cmdValue = command[0];\n        const { cmdKey, command: towerCommand } = this.getTowerCommand(cmdValue);\n\n        switch (cmdKey) {\n            case TC.STATE:\n            case TC.INVALID_STATE:\n            case TC.FAILURE:\n            case TC.JIGGLE:\n            case TC.UNEXPECTED:\n            case TC.DURATION:\n            case TC.DIFFERENTIAL:\n            case TC.CALIBRATION:\n                return [towerCommand.name, commandToPacketString(command)];\n            case TC.BATTERY: {\n                const millivolts = getMilliVoltsFromTowerResponse(command);\n                const retval = [towerCommand.name, milliVoltsToPercentage(millivolts)];\n                if (this.logDetail) {\n                    retval.push(`${millivolts}mv`);\n                    retval.push(commandToPacketString(command));\n                }\n                return retval;\n            }\n            default:\n                return [\"Unmapped Response!\", commandToPacketString(command)];\n        }\n    }\n\n\n    /**\n     * Determines if a response should be logged based on command type and configuration.\n     * @param {string} cmdKey - Command key from tower message\n     * @param {any} logConfig - Logging configuration object\n     * @returns {boolean} Whether this response should be logged\n     */\n    shouldLogResponse(cmdKey: string, logConfig: any): boolean {\n        const logAll = logConfig[\"LOG_ALL\"];\n        let canLogThisResponse = logConfig[cmdKey] || logAll;\n\n        // Log unknown commands by default for debugging\n        if (!cmdKey) {\n            canLogThisResponse = true;\n        }\n\n        return canLogThisResponse;\n    }\n\n    /**\n     * Checks if a command is a battery response type.\n     * @param {string} cmdKey - Command key from tower message\n     * @returns {boolean} True if this is a battery response\n     */\n    isBatteryResponse(cmdKey: string): boolean {\n        return cmdKey === TC.BATTERY;\n    }\n\n    /**\n     * Checks if a command is a tower state response type.\n     * @param {string} cmdKey - Command key from tower message\n     * @returns {boolean} True if this is a tower state response\n     */\n    isTowerStateResponse(cmdKey: string): boolean {\n        return cmdKey === TC.STATE;\n    }\n}", "import {\n    AUDIO_COMMAND_POS,\n    DRUM_PACKETS,\n    drumPositionCmds,\n    type TowerSide,\n    TOWER_COMMAND_PACKET_SIZE,\n    TOWER_STATE_DATA_SIZE,\n    TOWER_COMMAND_TYPE_TOWER_STATE,\n    TOWER_STATE_DATA_OFFSET\n} from './udtConstants';\nimport { type TowerState, type Audio, rtdt_pack_state } from './udtTowerState';\n\n\nexport class UdtCommandFactory {\n\n\n\n    /**\n     * Creates a rotation command packet for positioning tower drums.\n     * @param top - Target position for top drum\n     * @param middle - Target position for middle drum\n     * @param bottom - Target position for bottom drum\n     * @returns Command packet for rotating tower drums\n     */\n    createRotateCommand(top: TowerSide, middle: TowerSide, bottom: TowerSide): Uint8Array {\n        const rotateCmd = new Uint8Array(TOWER_COMMAND_PACKET_SIZE);\n        rotateCmd[DRUM_PACKETS.topMiddle] =\n            drumPositionCmds.top[top] | drumPositionCmds.middle[middle];\n        rotateCmd[DRUM_PACKETS.bottom] = drumPositionCmds.bottom[bottom];\n        return rotateCmd;\n    }\n\n    /**\n     * Creates a sound command packet for playing tower audio.\n     * @param soundIndex - Index of the sound to play from the audio library\n     * @returns Command packet for playing sound\n     */\n    createSoundCommand(soundIndex: number): Uint8Array {\n        const soundCommand = new Uint8Array(TOWER_COMMAND_PACKET_SIZE);\n        const sound = Number(\"0x\" + Number(soundIndex).toString(16).padStart(2, '0'));\n        soundCommand[AUDIO_COMMAND_POS] = sound;\n        return soundCommand;\n    }\n\n\n    /**\n     * Creates a basic tower command packet with the specified command value.\n     * @param commandValue - The command value to send\n     * @returns Basic command packet\n     */\n    createBasicCommand(commandValue: number): Uint8Array {\n        return new Uint8Array([commandValue]);\n    }\n\n    //#region Stateful Command Methods\n\n    /**\n     * Creates a stateful tower command by modifying only specific fields while preserving the rest.\n     * This is the proper way to send commands that only change certain aspects of the tower state.\n     * @param currentState - The current complete tower state (or null to create default state)\n     * @param modifications - Partial tower state with only the fields to modify\n     * @returns 20-byte command packet (command type + 19-byte state data)\n     */\n    createStatefulCommand(currentState: TowerState | null, modifications: Partial<TowerState>): Uint8Array {\n        // Start with current state or create default state\n        const newState: TowerState = currentState ? { ...currentState } : this.createEmptyTowerState();\n\n        // Apply modifications\n        if (modifications.drum) {\n            modifications.drum.forEach((drum, index) => {\n                if (drum && newState.drum[index]) {\n                    Object.assign(newState.drum[index], drum);\n                }\n            });\n        }\n\n        if (modifications.layer) {\n            modifications.layer.forEach((layer, layerIndex) => {\n                if (layer && newState.layer[layerIndex]) {\n                    if (layer.light) {\n                        layer.light.forEach((light, lightIndex) => {\n                            if (light && newState.layer[layerIndex].light[lightIndex]) {\n                                Object.assign(newState.layer[layerIndex].light[lightIndex], light);\n                            }\n                        });\n                    }\n                }\n            });\n        }\n\n        if (modifications.audio) {\n            Object.assign(newState.audio, modifications.audio);\n        }\n\n        if (modifications.beam) {\n            Object.assign(newState.beam, modifications.beam);\n        }\n\n        if (modifications.led_sequence !== undefined) {\n            newState.led_sequence = modifications.led_sequence;\n        }\n\n        // Pack the state into a command\n        return this.packTowerStateCommand(newState);\n    }\n\n    /**\n     * Creates a stateful LED command that only changes specific LEDs while preserving all other state.\n     * @param currentState - The current complete tower state\n     * @param layerIndex - Layer index (0-5)\n     * @param lightIndex - Light index within layer (0-3)\n     * @param effect - Light effect (0=off, 1=on, 2=slow pulse, etc.)\n     * @param loop - Whether to loop the effect\n     * @returns 20-byte command packet\n     */\n    createStatefulLEDCommand(\n        currentState: TowerState | null,\n        layerIndex: number,\n        lightIndex: number,\n        effect: number,\n        loop: boolean = false\n    ): Uint8Array {\n        const modifications: Partial<TowerState> = {};\n\n        // Create a targeted modification for only the specific light\n        if (!modifications.layer) {\n            modifications.layer = [] as any;\n        }\n        if (!modifications.layer[layerIndex]) {\n            modifications.layer[layerIndex] = { light: [] as any };\n        }\n        if (!modifications.layer[layerIndex].light) {\n            modifications.layer[layerIndex].light = [] as any;\n        }\n        modifications.layer[layerIndex].light[lightIndex] = { effect, loop };\n\n        // Always clear audio state for LED commands to prevent audio persistence\n        modifications.audio = { sample: 0, loop: false, volume: 0 };\n\n        return this.createStatefulCommand(currentState, modifications);\n    }\n\n    /**\n * Creates a stateful audio command that preserves all current tower state while adding audio.\n * @param currentState - The current complete tower state\n * @param sample - Audio sample index to play (0-127)\n * @param loop - Whether to loop the audio\n * @param volume - Audio volume (0-15), optional\n * @returns 20-byte command packet\n */\n    createStatefulAudioCommand(\n        currentState: TowerState | null,\n        sample: number,\n        loop: boolean = false,\n        volume?: number\n    ): Uint8Array {\n        const audioMods: Audio = { sample, loop, volume: volume ?? 0 };\n\n        const modifications: Partial<TowerState> = {\n            audio: audioMods\n        };\n\n        return this.createStatefulCommand(currentState, modifications);\n    }\n\n    /**\n     * Creates a transient audio command that includes current tower state but doesn't persist audio state.\n     * This prevents audio from being included in subsequent commands.\n     * @param currentState - The current complete tower state  \n     * @param sample - Audio sample index to play\n     * @param loop - Whether to loop the audio\n     * @param volume - Audio volume (0-15), optional\n     * @returns Object containing the command packet and the state without audio for local tracking\n     */\n    createTransientAudioCommand(\n        currentState: TowerState | null,\n        sample: number,\n        loop: boolean = false,\n        volume?: number\n    ): { command: Uint8Array; stateWithoutAudio: TowerState } {\n        // Create the command with audio\n        const audioMods: Audio = { sample, loop, volume: volume ?? 0 };\n\n        const modifications: Partial<TowerState> = {\n            audio: audioMods\n        };\n\n        const command = this.createStatefulCommand(currentState, modifications);\n\n        // Create state without audio for local tracking\n        const stateWithoutAudio: TowerState = currentState ? { ...currentState } : this.createEmptyTowerState();\n        // Reset audio to neutral state\n        stateWithoutAudio.audio = { sample: 0, loop: false, volume: 0 };\n\n        return { command, stateWithoutAudio };\n    }\n\n    /**\n     * Creates a transient audio command with additional modifications that includes current tower state \n     * but doesn't persist audio state. This prevents audio from being included in subsequent commands.\n     * @param currentState - The current complete tower state  \n     * @param sample - Audio sample index to play\n     * @param loop - Whether to loop the audio\n     * @param volume - Audio volume (0-15), optional\n     * @param otherModifications - Other tower state modifications to include\n     * @returns Object containing the command packet and the state with modifications but without audio\n     */\n    createTransientAudioCommandWithModifications(\n        currentState: TowerState | null,\n        sample: number,\n        loop: boolean = false,\n        volume: number | undefined = undefined,\n        otherModifications: Partial<TowerState> = {}\n    ): { command: Uint8Array; stateWithoutAudio: TowerState } {\n        // Create the command with audio and other modifications\n        const audioMods: Audio = { sample, loop, volume: volume ?? 0 };\n\n        const modifications: Partial<TowerState> = {\n            ...otherModifications,\n            audio: audioMods\n        };\n\n        const command = this.createStatefulCommand(currentState, modifications);\n\n        // Create state with other modifications but without audio for local tracking\n        const stateWithoutAudio: TowerState = currentState ? { ...currentState } : this.createEmptyTowerState();\n\n        // Apply other modifications\n        if (otherModifications.drum) {\n            otherModifications.drum.forEach((drum, index) => {\n                if (drum && stateWithoutAudio.drum[index]) {\n                    Object.assign(stateWithoutAudio.drum[index], drum);\n                }\n            });\n        }\n\n        if (otherModifications.layer) {\n            otherModifications.layer.forEach((layer, layerIndex) => {\n                if (layer && stateWithoutAudio.layer[layerIndex]) {\n                    if (layer.light) {\n                        layer.light.forEach((light, lightIndex) => {\n                            if (light && stateWithoutAudio.layer[layerIndex].light[lightIndex]) {\n                                Object.assign(stateWithoutAudio.layer[layerIndex].light[lightIndex], light);\n                            }\n                        });\n                    }\n                }\n            });\n        }\n\n        if (otherModifications.beam) {\n            Object.assign(stateWithoutAudio.beam, otherModifications.beam);\n        }\n\n        if (otherModifications.led_sequence !== undefined) {\n            stateWithoutAudio.led_sequence = otherModifications.led_sequence;\n        }\n\n        // Reset audio to neutral state (don't persist it)\n        stateWithoutAudio.audio = { sample: 0, loop: false, volume: 0 };\n\n        return { command, stateWithoutAudio };\n    }\n\n    /**\n     * Creates a stateful drum rotation command that only changes drum positions while preserving all other state.\n     * @param currentState - The current complete tower state\n     * @param drumIndex - Drum index (0=top, 1=middle, 2=bottom)\n     * @param position - Target position (0=north, 1=east, 2=south, 3=west)\n     * @param playSound - Whether to play sound during rotation\n     * @returns 20-byte command packet\n     */\n    createStatefulDrumCommand(\n        currentState: TowerState | null,\n        drumIndex: number,\n        position: number,\n        playSound: boolean = false\n    ): Uint8Array {\n        const modifications: Partial<TowerState> = {};\n\n        // Create a partial drum array with only the drum we want to modify\n        if (!modifications.drum) {\n            modifications.drum = [] as any;\n        }\n        modifications.drum[drumIndex] = {\n            jammed: false,\n            calibrated: true,\n            position,\n            playSound,\n            reverse: false\n        };\n\n        // Always clear audio state for drum commands to prevent audio persistence\n        modifications.audio = { sample: 0, loop: false, volume: 0 };\n\n        return this.createStatefulCommand(currentState, modifications);\n    }\n\n    /**\n     * Packs a complete tower state into a 20-byte command packet.\n     * @param state - Complete tower state to pack\n     * @returns 20-byte command packet (0x00 + 19 bytes state data)\n     */\n    packTowerStateCommand(state: TowerState): Uint8Array {\n        const stateData = new Uint8Array(TOWER_STATE_DATA_SIZE);\n        const success = rtdt_pack_state(stateData, TOWER_STATE_DATA_SIZE, state);\n\n        if (!success) {\n            throw new Error('Failed to pack tower state data');\n        }\n\n        // Create 20-byte command packet (command type 0x00 + 19 bytes state)\n        const command = new Uint8Array(TOWER_COMMAND_PACKET_SIZE);\n        command[0] = TOWER_COMMAND_TYPE_TOWER_STATE; // Command type for tower state\n        command.set(stateData, TOWER_STATE_DATA_OFFSET);\n\n        return command;\n    }\n\n    /**\n     * Creates a default tower state with all systems off/neutral.\n     * @returns Default TowerState object\n     */\n    private createEmptyTowerState(): TowerState {\n        return {\n            drum: [\n                { jammed: false, calibrated: false, position: 0, playSound: false, reverse: false },\n                { jammed: false, calibrated: false, position: 0, playSound: false, reverse: false },\n                { jammed: false, calibrated: false, position: 0, playSound: false, reverse: false }\n            ],\n            layer: [\n                { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] },\n                { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] },\n                { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] },\n                { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] },\n                { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] },\n                { light: [{ effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }, { effect: 0, loop: false }] }\n            ],\n            audio: { sample: 0, loop: false, volume: 0 },\n            beam: { count: 0, fault: false },\n            led_sequence: 0\n        };\n    }\n\n    //#endregion\n}", "import {\n    TOWER_COMMANDS,\n    TOWER_AUDIO_LIBRARY,\n    AUDIO_COMMAND_POS,\n    DRUM_PACKETS,\n    drumPositionCmds,\n    LIGHT_EFFECTS,\n    TOWER_LAYERS,\n    RING_LIGHT_POSITIONS,\n    LEDGE_BASE_LIGHT_POSITIONS,\n    type Lights,\n    type TowerSide,\n    type TowerCorner,\n    type TowerLevels,\n    type LedgeLight,\n    type DoorwayLight,\n    type SealIdentifier\n} from './udtConstants';\nimport { type TowerState } from './udtTowerState';\nimport { Logger } from './udtLogger';\nimport { UdtCommandFactory } from './udtCommandFactory';\nimport { UdtBleConnection } from './udtBleConnection';\nimport { TowerResponseProcessor } from './udtTowerResponse';\nimport { CommandQueue } from './udtCommandQueue';\nimport { commandToPacketString } from './udtHelpers';\n\n\nexport interface TowerCommandDependencies {\n    logger: Logger;\n    commandFactory: UdtCommandFactory;\n    bleConnection: UdtBleConnection;\n    responseProcessor: TowerResponseProcessor;\n    logDetail: boolean;\n    retrySendCommandCount: { value: number };\n    retrySendCommandMax: number;\n    getCurrentTowerState: () => TowerState;\n    setTowerState: (newState: TowerState, source: string) => void;\n}\n\nexport class UdtTowerCommands {\n    private deps: TowerCommandDependencies;\n    private commandQueue: CommandQueue;\n\n    constructor(dependencies: TowerCommandDependencies) {\n        this.deps = dependencies;\n\n        // Initialize command queue with the actual send function\n        this.commandQueue = new CommandQueue(\n            this.deps.logger,\n            (command: Uint8Array) => this.sendTowerCommandDirect(command)\n        );\n    }\n\n    /**\n     * Sends a command packet to the tower via the command queue\n     * @param command - The command packet to send to the tower\n     * @param description - Optional description for logging\n     * @returns Promise that resolves when command is completed\n     */\n    async sendTowerCommand(command: Uint8Array, description?: string): Promise<void> {\n        return await this.commandQueue.enqueue(command, description);\n    }\n\n    /**\n     * Directly sends a command packet to the tower via Bluetooth with error handling and retry logic.\n     * This method is used internally by the command queue.\n     * @param command - The command packet to send to the tower\n     * @returns Promise that resolves when command is sent successfully\n     */\n    private async sendTowerCommandDirect(command: Uint8Array): Promise<void> {\n        try {\n            const cmdStr = commandToPacketString(command);\n            this.deps.logDetail && this.deps.logger.debug(`${cmdStr}`, '[UDT][CMD]');\n            if (!this.deps.bleConnection.txCharacteristic || !this.deps.bleConnection.isConnected) {\n                this.deps.logger.warn('Tower is not connected', '[UDT][CMD]');\n                return;\n            }\n            await this.deps.bleConnection.txCharacteristic.writeValue(command);\n            this.deps.retrySendCommandCount.value = 0;\n            this.deps.bleConnection.lastSuccessfulCommand = Date.now();\n        } catch (error) {\n            this.deps.logger.error(`command send error: ${error}`, '[UDT][CMD]');\n            const errorMsg = error?.message ?? new String(error);\n            const wasCancelled = errorMsg.includes('User cancelled');\n            const maxRetriesReached = this.deps.retrySendCommandCount.value >= this.deps.retrySendCommandMax;\n\n            // Check for disconnect indicators\n            const isDisconnected = errorMsg.includes('Cannot read properties of null') ||\n                errorMsg.includes('GATT Server is disconnected') ||\n                errorMsg.includes('Device is not connected') ||\n                !this.deps.bleConnection.TowerDevice?.gatt?.connected;\n\n            if (isDisconnected) {\n                this.deps.logger.warn('Disconnect detected during command send', '[UDT][CMD]');\n                await this.deps.bleConnection.disconnect();\n                return;\n            }\n\n            if (!maxRetriesReached && this.deps.bleConnection.isConnected && !wasCancelled) {\n                this.deps.logger.info(`retrying tower command attempt ${this.deps.retrySendCommandCount.value + 1}`, '[UDT][CMD]');\n                this.deps.retrySendCommandCount.value++;\n                setTimeout(() => {\n                    this.sendTowerCommandDirect(command);\n                }, 250 * this.deps.retrySendCommandCount.value);\n            } else {\n                this.deps.retrySendCommandCount.value = 0;\n            }\n        }\n    }\n\n    /**\n     * Initiates tower calibration to determine the current position of all tower drums.\n     * This must be performed after connection before other tower operations.\n     * @returns Promise that resolves when calibration command is sent\n     */\n    async calibrate(): Promise<void> {\n        if (!this.deps.bleConnection.performingCalibration) {\n            this.deps.logger.info('Performing Tower Calibration', '[UDT][CMD]');\n            await this.sendTowerCommand(new Uint8Array([TOWER_COMMANDS.calibration]), 'calibrate');\n\n            // flag to look for calibration complete tower response\n            this.deps.bleConnection.performingCalibration = true;\n            this.deps.bleConnection.performingLongCommand = true;\n            return;\n        }\n\n        this.deps.logger.warn('Tower calibration requested when tower is already performing calibration', '[UDT][CMD]');\n        return;\n    }\n\n    /**\n     * Plays a sound from the tower's audio library using stateful commands that preserve existing tower state.\n     * Audio state is not persisted to prevent sounds from replaying on subsequent commands.\n     * @param soundIndex - Index of the sound to play (1-based, must be valid in TOWER_AUDIO_LIBRARY)\n     * @returns Promise that resolves when sound command is sent\n     */\n    async playSound(soundIndex: number): Promise<void> {\n        const invalidIndex = soundIndex === null || soundIndex > (Object.keys(TOWER_AUDIO_LIBRARY).length) || soundIndex <= 0;\n        if (invalidIndex) {\n            this.deps.logger.error(`attempt to play invalid sound index ${soundIndex}`, '[UDT][CMD]');\n            return;\n        }\n\n        const currentState = this.deps.getCurrentTowerState();\n        const { command } = this.deps.commandFactory.createTransientAudioCommand(currentState, soundIndex, false);\n\n        this.deps.logger.info('Sending sound command (stateful)', '[UDT][CMD]');\n\n        // Send the command directly without updating state tracking \n        // Audio should not persist in state as it's a transient effect\n        await this.sendTowerCommand(command, `playSound(${soundIndex})`);\n    }\n\n    /**\n     * Controls the tower's LED lights including doorway, ledge, and base lights.\n     * @param lights - Light configuration object specifying which lights to control and their effects\n     * @returns Promise that resolves when light command is sent\n     */\n    async lights(lights: Lights): Promise<void> {\n        this.deps.logDetail && this.deps.logger.debug(`Light Parameter ${JSON.stringify(lights)}`, '[UDT][CMD]');\n        this.deps.logger.info('Sending light commands', '[UDT][CMD]');\n\n        // Convert lights object to individual setLEDStateful calls\n        const layerCommands = this.mapLightsToLayerCommands(lights);\n\n        // Execute all light commands\n        for (const { layerIndex, lightIndex, effect } of layerCommands) {\n            await this.setLEDStateful(layerIndex, lightIndex, effect);\n        }\n    }\n\n    /**\n     * Maps the Lights object to layer/light index commands for setLEDStateful.\n     * @param lights - Light configuration object\n     * @returns Array of layer commands\n     */\n    private mapLightsToLayerCommands(lights: Lights): Array<{ layerIndex: number, lightIndex: number, effect: number, loop: boolean }> {\n        const commands: Array<{ layerIndex: number, lightIndex: number, effect: number, loop: boolean }> = [];\n\n        // Map doorway lights (top, middle, bottom rings), assumes true on loop param\n        if (lights.doorway) {\n            for (const doorwayLight of lights.doorway) {\n                const layerIndex = this.getTowerLayerForLevel(doorwayLight.level);\n                const lightIndex = this.getLightIndexForSide(doorwayLight.position);\n                const effect = LIGHT_EFFECTS[doorwayLight.style] || LIGHT_EFFECTS.off;\n                console.log('[cek] effect', doorwayLight.style, effect);\n                commands.push({ layerIndex, lightIndex, effect, loop: true });\n            }\n        }\n\n        // Map ledge lights\n        if (lights.ledge) {\n            for (const ledgeLight of lights.ledge) {\n                const layerIndex = TOWER_LAYERS.LEDGE;\n                const lightIndex = this.getLedgeLightIndexForSide(ledgeLight.position);\n                const effect = LIGHT_EFFECTS[ledgeLight.style] || LIGHT_EFFECTS.off;\n                commands.push({ layerIndex, lightIndex, effect, loop: false });\n            }\n        }\n\n        // Map base lights (BASE1 and BASE2)\n        if (lights.base) {\n            for (const baseLight of lights.base) {\n                // Handle both HTML attributes ('a', 'b') and proper type definitions ('bottom', 'top')\n                // 'a' or 'bottom' -> BASE1 (layer 4), 'b' or 'top' -> BASE2 (layer 5)\n                const layerIndex = (baseLight.position.level === 'top' || baseLight.position.level === 'b') ? TOWER_LAYERS.BASE2 : TOWER_LAYERS.BASE1;\n                const lightIndex = this.getBaseLightIndexForSide(baseLight.position.side);\n                const effect = LIGHT_EFFECTS[baseLight.style] || LIGHT_EFFECTS.off;\n                commands.push({ layerIndex, lightIndex, effect, loop: false });\n            }\n        }\n\n        return commands;\n    }\n\n    /**\n     * Gets the tower layer index for a doorway light level.\n     * @param level - Tower level (top, middle, bottom)\n     * @returns Layer index\n     */\n    private getTowerLayerForLevel(level: TowerLevels): number {\n        switch (level) {\n            case 'top': return TOWER_LAYERS.TOP_RING;\n            case 'middle': return TOWER_LAYERS.MIDDLE_RING;\n            case 'bottom': return TOWER_LAYERS.BOTTOM_RING;\n            default: return TOWER_LAYERS.TOP_RING;\n        }\n    }\n\n    /**\n     * Gets the light index for a cardinal direction (ring lights).\n     * @param side - Tower side (north, east, south, west)\n     * @returns Light index\n     */\n    private getLightIndexForSide(side: TowerSide): number {\n        switch (side) {\n            case 'north': return RING_LIGHT_POSITIONS.NORTH;\n            case 'east': return RING_LIGHT_POSITIONS.EAST;\n            case 'south': return RING_LIGHT_POSITIONS.SOUTH;\n            case 'west': return RING_LIGHT_POSITIONS.WEST;\n            default: return RING_LIGHT_POSITIONS.NORTH;\n        }\n    }\n\n    /**\n     * Maps cardinal directions to their closest corner positions for ledge lights.\n     * @param side - Tower side (north, east, south, west)\n     * @returns Tower corner (northeast, southeast, southwest, northwest)\n     */\n    private mapSideToCorner(side: TowerSide): TowerCorner {\n        switch (side) {\n            case 'north': return 'northeast';\n            case 'east': return 'southeast';\n            case 'south': return 'southwest';\n            case 'west': return 'northwest';\n            default: return 'northeast';\n        }\n    }\n\n    /**\n     * Gets the light index for ledge lights (ordinal directions).\n     * @param corner - Tower corner (northeast, southeast, southwest, northwest)\n     * @returns Light index\n     */\n    private getLedgeLightIndexForSide(corner: TowerCorner): number {\n        // Map ordinal directions directly to ledge light positions\n        switch (corner) {\n            case 'northeast': return LEDGE_BASE_LIGHT_POSITIONS.NORTH_EAST;\n            case 'southeast': return LEDGE_BASE_LIGHT_POSITIONS.SOUTH_EAST;\n            case 'southwest': return LEDGE_BASE_LIGHT_POSITIONS.SOUTH_WEST;\n            case 'northwest': return LEDGE_BASE_LIGHT_POSITIONS.NORTH_WEST;\n            default: return LEDGE_BASE_LIGHT_POSITIONS.NORTH_EAST;\n        }\n    }\n\n    /**\n     * Gets the light index for base lights (ordinal directions).\n     * @param side - Tower side (north, east, south, west)\n     * @returns Light index\n     */\n    private getBaseLightIndexForSide(side: TowerSide): number {\n        // Convert cardinal direction to corner and get light index\n        return this.getLedgeLightIndexForSide(this.mapSideToCorner(side));\n    }\n\n    /**\n     * Sends a light override command to control specific light patterns using stateful commands.\n     * @param light - Light override value to send\n     * @param soundIndex - Optional sound to play with the light override\n     * @returns Promise that resolves when light override command is sent\n     */\n    async lightOverrides(light: number, soundIndex?: number): Promise<void> {\n        // Validate light parameter\n        if (typeof light !== 'number' || isNaN(light)) {\n            this.deps.logger.error(`Invalid light parameter: ${light}. Must be a valid number.`, '[UDT][CMD]');\n            return;\n        }\n\n        // Validate soundIndex if provided\n        if (soundIndex !== undefined && (typeof soundIndex !== 'number' || isNaN(soundIndex) || soundIndex <= 0)) {\n            this.deps.logger.error(`Invalid soundIndex parameter: ${soundIndex}. Must be a valid positive number.`, '[UDT][CMD]');\n            return;\n        }\n\n        const currentState = this.deps.getCurrentTowerState();\n\n        if (soundIndex) {\n            // Use transient audio command with LED sequence modification\n            const { command, stateWithoutAudio } = this.deps.commandFactory.createTransientAudioCommandWithModifications(\n                currentState,\n                soundIndex,\n                false,\n                undefined,\n                { led_sequence: light }\n            );\n\n            this.deps.logger.info('Sending stateful light override with sound', '[UDT][CMD]');\n\n            // Update our state tracking without the audio\n            this.deps.setTowerState(stateWithoutAudio, 'lightOverrides');\n\n            await this.sendTowerCommand(command, `lightOverrides(${light}, ${soundIndex})`);\n        } else {\n            // Create modifications for the light override only\n            const modifications: Partial<TowerState> = {\n                led_sequence: light\n            };\n\n            const command = this.deps.commandFactory.createStatefulCommand(currentState, modifications);\n\n            this.deps.logger.info('Sending stateful light override', '[UDT][CMD]');\n            await this.sendTowerCommand(command, `lightOverrides(${light})`);\n        }\n    }\n\n    /**\n     * Rotates tower drums to specified positions.\n     * @param top - Position for the top drum ('north', 'east', 'south', 'west')\n     * @param middle - Position for the middle drum\n     * @param bottom - Position for the bottom drum\n     * @param soundIndex - Optional sound to play during rotation\n     * @returns Promise that resolves when rotate command is sent\n     */\n    async rotate(top: TowerSide, middle: TowerSide, bottom: TowerSide, soundIndex?: number): Promise<void> {\n        this.deps.logDetail && this.deps.logger.debug(`Rotate Parameter TMB[${JSON.stringify(top)}|${middle}|${bottom}] S[${soundIndex}]`, '[UDT][CMD]');\n\n        const rotateCommand = this.deps.commandFactory.createRotateCommand(top, middle, bottom);\n\n        if (soundIndex) {\n            rotateCommand[AUDIO_COMMAND_POS] = soundIndex;\n        }\n\n        this.deps.logger.info('Sending rotate command' + (soundIndex ? ' with sound' : ''), '[UDT]');\n\n        // Flag that we're performing a long command \n        // drum rotation can exceed battery heartbeat check default\n        this.deps.bleConnection.performingLongCommand = true;\n        await this.sendTowerCommand(rotateCommand, `rotate(${top}, ${middle}, ${bottom}${soundIndex ? `, ${soundIndex}` : ''})`);\n\n        // Reset the long command flag after a delay to allow for rotation completion\n        // Drum rotation time varies based on number of drums moved\n        setTimeout(() => {\n            this.deps.bleConnection.performingLongCommand = false;\n            this.deps.bleConnection.lastBatteryHeartbeat = Date.now(); // Reset heartbeat timer\n        }, this.deps.bleConnection.longTowerCommandTimeout);\n\n        // Update drum positions in tower state from the rotation command\n        const towerState = this.deps.getCurrentTowerState();\n        if (towerState) {\n            // Extract drum positions from the raw command bytes\n            const topMiddleRaw = rotateCommand[DRUM_PACKETS.topMiddle];\n            const bottomRaw = rotateCommand[DRUM_PACKETS.bottom];\n\n            // Decode positions for each drum from raw values\n            const topPosition = this.decodeDrumPositionFromRaw('top', topMiddleRaw);\n            const middlePosition = this.decodeDrumPositionFromRaw('middle', topMiddleRaw);\n            const bottomPosition = this.decodeDrumPositionFromRaw('bottom', bottomRaw);\n\n            // Update tower state\n            towerState.drum[0].position = topPosition;\n            towerState.drum[1].position = middlePosition;\n            towerState.drum[2].position = bottomPosition;\n        }\n    }\n\n    /**\n   * Rotates tower drums to specified positions.\n   * @param top - Position for the top drum ('north', 'east', 'south', 'west')\n   * @param middle - Position for the middle drum\n   * @param bottom - Position for the bottom drum\n   * @param soundIndex - Optional sound to play during rotation\n   * @returns Promise that resolves when rotate command is sent\n   */\n    async rotateWithState(top: TowerSide, middle: TowerSide, bottom: TowerSide, soundIndex?: number): Promise<void> {\n        this.deps.logDetail && this.deps.logger.debug(`Rotate Parameter TMB[${JSON.stringify(top)}|${middle}|${bottom}] S[${soundIndex}]`, '[UDT][CMD]');\n\n        // Convert TowerSide to numeric positions\n        const positionMap: { [key in TowerSide]: number } = {\n            'north': 0, 'east': 1, 'south': 2, 'west': 3\n        };\n\n        this.deps.logger.info('Sending stateful rotate commands' + (soundIndex ? ' with sound' : ''), '[UDT][CMD]');\n\n        // Flag that we're performing a long command \n        // drum rotation can exceed battery heartbeat check default\n        this.deps.bleConnection.performingLongCommand = true;\n\n        try {\n            // Rotate each drum individually using the proven single-drum stateful commands\n            // This approach is more reliable than trying to change all drums in one command\n            await this.rotateDrumStateful(0, positionMap[top], false);\n            await this.rotateDrumStateful(1, positionMap[middle], false);\n            await this.rotateDrumStateful(2, positionMap[bottom], false);\n\n            // Play sound if requested - do this after all rotations to avoid conflicts\n            if (soundIndex) {\n                await this.playSound(soundIndex);\n            }\n\n        } finally {\n            // Reset the long command flag after a delay to allow for rotation completion\n            // Drum rotation time varies based on number of drums moved\n            setTimeout(() => {\n                this.deps.bleConnection.performingLongCommand = false;\n                this.deps.bleConnection.lastBatteryHeartbeat = Date.now(); // Reset heartbeat timer\n            }, this.deps.bleConnection.longTowerCommandTimeout);\n\n            // Update drum positions in tower state - with stateful commands we know the exact positions\n            const towerState = this.deps.getCurrentTowerState();\n            if (towerState) {\n                towerState.drum[0].position = positionMap[top];\n                towerState.drum[1].position = positionMap[middle];\n                towerState.drum[2].position = positionMap[bottom];\n            }\n        }\n    }\n\n    /**\n     * Resets the tower's internal skull drop counter to zero using stateful commands.\n     * @returns Promise that resolves when reset command is sent\n     */\n    async resetTowerSkullCount(): Promise<void> {\n        this.deps.logger.info('Tower skull count reset requested', '[UDT][CMD]');\n\n        const currentState = this.deps.getCurrentTowerState();\n        const modifications: Partial<TowerState> = {\n            beam: { count: 0, fault: false }\n        };\n\n        const command = this.deps.commandFactory.createStatefulCommand(currentState, modifications);\n        await this.sendTowerCommand(command, 'resetTowerSkullCount');\n\n        // Update skull count in local tower state immediately to trigger UI refresh\n        // This technically shouldn't be necessary, need to investiage\n        // TODO: Why doesn't command coming back reflect zero skulls ...\n        //       could be due to using problematic tower (not using my good tower at the moment)\n        const updatedState = { ...currentState };\n        updatedState.beam.count = 0;\n        this.deps.setTowerState(updatedState, 'resetTowerSkullCount');\n    }\n\n    /**\n     * Breaks a single seal on the tower, playing appropriate sound and lighting effects.\n     * @param seal - Seal identifier to break (e.g., {side: 'north', level: 'middle'})\n     * @param volume - Optional volume override (0=loud, 1=medium, 2=quiet, 3=mute). Uses current tower state if not provided.\n     * @returns Promise that resolves when seal break sequence is complete\n     */\n    async breakSeal(seal: SealIdentifier, volume?: number): Promise<void> {\n        // Get the volume to use\n        const actualVolume = volume !== undefined ? volume : this.deps.getCurrentTowerState().audio.volume;\n\n        // Update tower's internal volume state first - tower firmware ignores volume in sound commands\n        // and only uses its internal global volume state\n        if (actualVolume > 0) {\n            const currentState = this.deps.getCurrentTowerState();\n            const stateWithVolume = { ...currentState };\n            stateWithVolume.audio = { sample: 0, loop: false, volume: actualVolume };\n            await this.sendTowerStateStateful(stateWithVolume);\n        }\n\n        this.deps.logger.info('Playing tower seal sound', '[UDT]');\n        await this.playSoundStateful(TOWER_AUDIO_LIBRARY.TowerSeal.value, false, actualVolume);\n\n        // Light both corner ledges that share the same side\n        // For each cardinal direction, light both corners that include that direction\n        const sideCorners: { [key in TowerSide]: [TowerCorner, TowerCorner] } = {\n            north: ['northeast', 'northwest'],\n            east: ['northeast', 'southeast'],\n            south: ['southeast', 'southwest'],\n            west: ['southwest', 'northwest']\n        };\n\n        const ledgeLights: LedgeLight[] = sideCorners[seal.side].map(corner => ({\n            position: corner,\n            style: 'on'\n        }));\n\n        // Create doorway light with light effect for the broken seal\n        const doorwayLights: DoorwayLight[] = [{\n            level: seal.level,\n            position: seal.side,\n            style: 'breatheFast'\n        }];\n\n        const lights: Lights = {\n            ledge: ledgeLights,\n            doorway: doorwayLights\n        };\n\n        this.deps.logger.info(`Breaking seal ${seal.level}-${seal.side} - lighting ledges and doorways with breath effect`, '[UDT]');\n        await this.lights(lights);\n    }\n\n    /**\n     * Randomly rotates specified tower levels to random positions.\n     * @param level - Level configuration: 0=all, 1=top, 2=middle, 3=bottom, 4=top&middle, 5=top&bottom, 6=middle&bottom\n     * @returns Promise that resolves when rotation command is sent\n     */\n    async randomRotateLevels(level: number = 0): Promise<void> {\n        // 0 = all, 1 = top, 2 = middle, 3 = bottom\n        // 4 = top & middle, 5 = top & bottom, 6 = middle & bottom\n\n        const sides: TowerSide[] = ['north', 'east', 'south', 'west'];\n        const getRandomSide = (): TowerSide => sides[Math.floor(Math.random() * sides.length)];\n\n        // Current positions to preserve unchanged levels\n        const currentTop = this.getCurrentDrumPosition('top');\n        const currentMiddle = this.getCurrentDrumPosition('middle');\n        const currentBottom = this.getCurrentDrumPosition('bottom');\n\n        let topSide: TowerSide, middleSide: TowerSide, bottomSide: TowerSide;\n\n        switch (level) {\n            case 0: // all levels\n                topSide = getRandomSide();\n                middleSide = getRandomSide();\n                bottomSide = getRandomSide();\n                break;\n            case 1: // top only\n                topSide = getRandomSide();\n                middleSide = currentMiddle;\n                bottomSide = currentBottom;\n                break;\n            case 2: // middle only\n                topSide = currentTop;\n                middleSide = getRandomSide();\n                bottomSide = currentBottom;\n                break;\n            case 3: // bottom only\n                topSide = currentTop;\n                middleSide = currentMiddle;\n                bottomSide = getRandomSide();\n                break;\n            case 4: // top & middle\n                topSide = getRandomSide();\n                middleSide = getRandomSide();\n                bottomSide = currentBottom;\n                break;\n            case 5: // top & bottom\n                topSide = getRandomSide();\n                middleSide = currentMiddle;\n                bottomSide = getRandomSide();\n                break;\n            case 6: // middle & bottom\n                topSide = currentTop;\n                middleSide = getRandomSide();\n                bottomSide = getRandomSide();\n                break;\n            default:\n                this.deps.logger.error('Invalid level parameter for randomRotateLevels. Must be 0-6.', '[UDT][CMD]');\n                return;\n        }\n\n        this.deps.logger.info(`Random rotating levels to: top:${topSide}, middle:${middleSide}, bottom:${bottomSide}`, '[UDT][CMD]');\n        await this.rotate(topSide, middleSide, bottomSide);\n    }\n\n    /**\n     * Decodes drum position from raw command byte value.\n     * @param level - The drum level ('top', 'middle', 'bottom')\n     * @param rawValue - The raw byte value from the command\n     * @returns The position as a number (0=north, 1=east, 2=south, 3=west)\n     */\n    private decodeDrumPositionFromRaw(level: 'top' | 'middle' | 'bottom', rawValue: number): number {\n        const drumPositions = drumPositionCmds[level];\n\n        // Find matching side for current drum position\n        for (const [side, value] of Object.entries(drumPositions)) {\n            if (level === 'middle') {\n                // For middle, compare the middle-specific bits (bits 6-7)\n                if ((value & 0b11000000) === (rawValue & 0b11000000)) {\n                    return ['north', 'east', 'south', 'west'].indexOf(side);\n                }\n            } else if (level === 'top') {\n                // For top drum, compare the top-specific bits (bits 1, 2, 4)\n                if ((value & 0b00010110) === (rawValue & 0b00010110)) {\n                    return ['north', 'east', 'south', 'west'].indexOf(side);\n                }\n            } else {\n                // For bottom, direct comparison\n                if (value === rawValue) {\n                    return ['north', 'east', 'south', 'west'].indexOf(side);\n                }\n            }\n        }\n\n        // Default to north (0) if no match found\n        return 0;\n    }\n\n    /**\n     * Gets the current position of a specific drum level.\n     * @param level - The drum level to get position for\n     * @returns The current position of the specified drum level\n     */\n    getCurrentDrumPosition(level: 'top' | 'middle' | 'bottom'): TowerSide {\n        const towerState = this.deps.getCurrentTowerState();\n        if (!towerState) {\n            return 'north';\n        }\n\n        const drumIndex = level === 'top' ? 0 : level === 'middle' ? 1 : 2;\n        const position = towerState.drum[drumIndex].position;\n\n        // Convert numeric position to TowerSide (0=north, 1=east, 2=south, 3=west)\n        const sides: TowerSide[] = ['north', 'east', 'south', 'west'];\n        return sides[position] || 'north';\n    }\n\n    //#region Stateful Command Methods\n\n    /**\n     * Sends a stateful LED command that only changes specific LEDs while preserving all other state.\n     * @param layerIndex - Layer index (0-5)\n     * @param lightIndex - Light index within layer (0-3)\n     * @param effect - Light effect (0=off, 1=on, 2=slow pulse, etc.)\n     * @param loop - Whether to loop the effect, defaults to true\n     * @returns Promise that resolves when command is sent\n     */\n    async setLEDStateful(layerIndex: number, lightIndex: number, effect: number, loop: boolean = true): Promise<void> {\n        const currentState = this.deps.getCurrentTowerState();\n        const command = this.deps.commandFactory.createStatefulLEDCommand(currentState, layerIndex, lightIndex, effect, loop);\n\n        this.deps.logger.info(`Setting LED layer ${layerIndex} light ${lightIndex} to effect ${effect}${loop ? ' (looped)' : ''}`, '[UDT][CMD]');\n        await this.sendTowerCommand(command, `setLEDStateful(${layerIndex}, ${lightIndex}, ${effect}, ${loop})`);\n    }\n\n    /**\n     * Plays a sound using stateful commands that preserve existing tower state.\n     * Audio state is not persisted to prevent sounds from replaying on subsequent commands.\n     * @param soundIndex - Index of the sound to play (1-based)\n     * @param loop - Whether to loop the audio\n     * @param volume - Audio volume (0-15), optional\n     * @returns Promise that resolves when command is sent\n     */\n    async playSoundStateful(soundIndex: number, loop: boolean = false, volume?: number): Promise<void> {\n        const invalidIndex = soundIndex === null || soundIndex > (Object.keys(TOWER_AUDIO_LIBRARY).length) || soundIndex <= 0;\n        if (invalidIndex) {\n            this.deps.logger.error(`attempt to play invalid sound index ${soundIndex}`, '[UDT][CMD]');\n            return;\n        }\n\n        const currentState = this.deps.getCurrentTowerState();\n        const { command } = this.deps.commandFactory.createTransientAudioCommand(currentState, soundIndex, loop, volume);\n\n        this.deps.logger.info(`Playing sound ${soundIndex}${loop ? ' (looped)' : ''}${volume !== undefined ? ` at volume ${volume}` : ''}`, '[UDT][CMD]');\n\n        // Send the command directly without updating state tracking\n        // Audio should not persist in state as it's a transient effect\n        await this.sendTowerCommand(command, `playSoundStateful(${soundIndex}, ${loop}${volume !== undefined ? `, ${volume}` : ''})`);\n    }\n\n    /**\n     * Rotates a single drum using stateful commands that preserve existing tower state.\n     * @param drumIndex - Drum index (0=top, 1=middle, 2=bottom)\n     * @param position - Target position (0=north, 1=east, 2=south, 3=west)\n     * @param playSound - Whether to play sound during rotation\n     * @returns Promise that resolves when command is sent\n     */\n    async rotateDrumStateful(drumIndex: number, position: number, playSound: boolean = false): Promise<void> {\n        const currentState = this.deps.getCurrentTowerState();\n        const command = this.deps.commandFactory.createStatefulDrumCommand(currentState, drumIndex, position, playSound);\n\n        const drumNames = ['top', 'middle', 'bottom'];\n        const positionNames = ['north', 'east', 'south', 'west'];\n        this.deps.logger.info(`Rotating ${drumNames[drumIndex]} drum to ${positionNames[position]}${playSound ? ' with sound' : ''}`, '[UDT][CMD]');\n\n        // Flag that we're performing a long command\n        this.deps.bleConnection.performingLongCommand = true;\n        await this.sendTowerCommand(command, `rotateDrumStateful(${drumIndex}, ${position}, ${playSound})`);\n\n        // Reset the long command flag after a delay\n        setTimeout(() => {\n            this.deps.bleConnection.performingLongCommand = false;\n            this.deps.bleConnection.lastBatteryHeartbeat = Date.now();\n        }, this.deps.bleConnection.longTowerCommandTimeout);\n    }\n\n    /**\n     * Sends a complete tower state using stateful commands.\n     * Audio state is automatically cleared to prevent sounds from persisting across commands.\n     * @param state - Complete tower state to send\n     * @returns Promise that resolves when command is sent\n     */\n    async sendTowerStateStateful(state: TowerState): Promise<void> {\n        // Create a copy of the state and clear audio to prevent persistence\n        const stateToSend = { ...state };\n        stateToSend.audio = { sample: 0, loop: false, volume: 0 };\n\n        const command = this.deps.commandFactory.packTowerStateCommand(stateToSend);\n\n        this.deps.logger.info('Sending complete tower state', '[UDT][CMD]');\n\n        // Update our local state tracking without audio\n        this.deps.setTowerState(stateToSend, 'sendTowerStateStateful');\n\n        await this.sendTowerCommand(command, 'sendTowerStateStateful');\n    }\n\n    //#endregion\n\n    /**\n     * Public access to sendTowerCommandDirect for testing purposes.\n     * This bypasses the command queue and sends commands directly.\n     * @param command - The command packet to send directly to the tower\n     * @returns Promise that resolves when command is sent\n     */\n    async sendTowerCommandDirectPublic(command: Uint8Array): Promise<void> {\n        return await this.sendTowerCommandDirect(command);\n    }\n\n    /**\n     * Called when a tower response is received to notify the command queue\n     * This should be called from the BLE connection response handler\n     */\n    onTowerResponse(): void {\n        this.commandQueue.onResponse();\n    }\n\n    /**\n     * Get command queue status for debugging\n     */\n    getQueueStatus() {\n        return this.commandQueue.getStatus();\n    }\n\n    /**\n     * Clear the command queue (for cleanup or error recovery)\n     */\n    clearQueue(): void {\n        this.commandQueue.clear();\n    }\n}", "import { Logger } from './udtLogger';\n\n/**\n * Internal interface for queued commands\n * @private\n */\ninterface QueuedCommand {\n    id: string;\n    command: Uint8Array;\n    timestamp: number;\n    resolve: (value: void) => void;\n    reject: (error: Error) => void;\n    description?: string;\n}\n\n/**\n * Internal command queue for managing sequential tower command processing\n * @private\n */\nexport class CommandQueue {\n    private queue: QueuedCommand[] = [];\n    private currentCommand: QueuedCommand | null = null;\n    private timeoutHandle: ReturnType<typeof setTimeout> | null = null;\n    private isProcessing: boolean = false;\n    private readonly timeoutMs: number = 30000; // 30 seconds\n    \n    constructor(\n        private logger: Logger,\n        private sendCommandFn: (command: Uint8Array) => Promise<void>\n    ) {}\n\n    /**\n     * Enqueue a command for processing\n     */\n    async enqueue(command: Uint8Array, description?: string): Promise<void> {\n        return new Promise<void>((resolve, reject) => {\n            const queuedCommand: QueuedCommand = {\n                id: `cmd_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n                command,\n                timestamp: Date.now(),\n                resolve,\n                reject,\n                description\n            };\n\n            this.queue.push(queuedCommand);\n            this.logger.debug(`Command queued: ${description || 'unnamed'} (queue size: ${this.queue.length})`, '[UDT]');\n            \n            // Start processing if not already running\n            if (!this.isProcessing) {\n                this.processNext();\n            }\n        });\n    }\n\n    /**\n     * Process the next command in the queue\n     */\n    private async processNext(): Promise<void> {\n        if (this.isProcessing || this.queue.length === 0) {\n            return;\n        }\n\n        this.isProcessing = true;\n        this.currentCommand = this.queue.shift()!;\n\n        const { id, command, description, reject } = this.currentCommand;\n        \n        this.logger.debug(`Processing command: ${description || id}`, '[UDT]');\n\n        try {\n            // Set timeout for command completion\n            this.timeoutHandle = setTimeout(() => {\n                this.onTimeout();\n            }, this.timeoutMs);\n\n            // Send the command using the existing sendTowerCommand logic\n            await this.sendCommandFn(command);\n            \n            // Command was sent successfully, now we wait for a response\n            // The response will be handled by onResponse() method\n            \n        } catch (error) {\n            // Command failed to send, reject and move to next\n            this.clearTimeout();\n            this.currentCommand = null;\n            this.isProcessing = false;\n            \n            reject(error as Error);\n            \n            // Continue processing next command\n            this.processNext();\n        }\n    }\n\n    /**\n     * Called when a tower response is received\n     */\n    onResponse(): void {\n        if (this.currentCommand) {\n            this.clearTimeout();\n            \n            const { resolve, description, id } = this.currentCommand;\n            this.logger.debug(`Command completed: ${description || id}`, '[UDT]');\n            \n            this.currentCommand = null;\n            this.isProcessing = false;\n            \n            resolve();\n            \n            // Process next command in queue\n            this.processNext();\n        }\n    }\n\n    /**\n     * Handle command timeout\n     */\n    private onTimeout(): void {\n        if (this.currentCommand) {\n            const { description, id } = this.currentCommand;\n            this.logger.warn(`Command timeout after ${this.timeoutMs}ms: ${description || id}`, '[UDT]');\n            \n            // Don't reject the promise - just log and continue\n            // This allows the queue to continue processing even if a command times out\n            this.currentCommand.resolve();\n            \n            this.currentCommand = null;\n            this.isProcessing = false;\n            \n            // Process next command in queue\n            this.processNext();\n        }\n    }\n\n    /**\n     * Clear the current timeout\n     */\n    private clearTimeout(): void {\n        if (this.timeoutHandle) {\n            clearTimeout(this.timeoutHandle);\n            this.timeoutHandle = null;\n        }\n    }\n\n    /**\n     * Clear all pending commands\n     */\n    clear(): void {\n        this.clearTimeout();\n        \n        // Reject all pending commands\n        this.queue.forEach(cmd => {\n            cmd.reject(new Error('Command queue cleared'));\n        });\n        \n        this.queue = [];\n        if (this.currentCommand) {\n            this.currentCommand.reject(new Error('Command queue cleared'));\n        }\n        this.currentCommand = null;\n        this.isProcessing = false;\n        \n        this.logger.debug('Command queue cleared', '[UDT]');\n    }\n\n    /**\n     * Get queue status for debugging\n     */\n    getStatus() {\n        return {\n            queueLength: this.queue.length,\n            isProcessing: this.isProcessing,\n            currentCommand: this.currentCommand ? {\n                id: this.currentCommand.id,\n                description: this.currentCommand.description,\n                timestamp: this.currentCommand.timestamp\n            } : null\n        };\n    }\n}", "/**\n * UltimateDarkTower - Main entry point\n * Export the main class and constants for public use\n */\n\nexport { default as UltimateDarkTower } from './UltimateDarkTower';\nexport * from './udtConstants';\nexport { logger, Logger, ConsoleOutput, DOMOutput, BufferOutput, type LogLevel, type LogOutput } from './udtLogger';\nexport { milliVoltsToPercentage, milliVoltsToPercentageNumber } from './udtHelpers';\n\n// For convenience, also export as default\nimport UltimateDarkTower from './UltimateDarkTower';\nexport default UltimateDarkTower;\n", "import UltimateDarkTower, {\n  type TowerSide,\n  type TowerCorner,\n  type TowerLevels,\n  type DoorwayLight,\n  type LedgeLight,\n  type BaseLight,\n  type BaseLightLevel,\n  type Lights,\n  type SealIdentifier,\n  type Glyphs,\n  TOWER_AUDIO_LIBRARY,\n  TOWER_LIGHT_SEQUENCES,\n  LIGHT_EFFECTS,\n  TOWER_LAYERS,\n  RING_LIGHT_POSITIONS,\n  LEDGE_BASE_LIGHT_POSITIONS,\n  GLYPHS,\n  VOLUME_DESCRIPTIONS,\n  VOLUME_ICONS\n} from '../../src';\nimport { logger, DOMOutput, ConsoleOutput } from '../../src/udtLogger';\nimport { rtdt_pack_state, rtdt_unpack_state, type TowerState } from '../../src/udtTowerState';\nimport { createDefaultTowerState } from '../../src/udtHelpers';\n\nconst Tower = new UltimateDarkTower();\n\n// Global reference to shared DOM output for filtering\nlet sharedDOMOutput: DOMOutput;\n\n// Setup loggers with DOM output after DOM is ready\nconst initializeLogger = () => {\n  // Create single shared DOM output with 1000 max lines\n  sharedDOMOutput = new DOMOutput('log-container', 1000);\n\n  // Configure Tower to use both console and shared DOM output\n  Tower.setLoggerOutputs([new ConsoleOutput(), sharedDOMOutput]);\n\n  // Enable detailed logging to see all [UDT] messages\n  Tower.logDetail = true;\n\n  // Configure TowerController logger to use the same shared DOM output\n  logger.addOutput(sharedDOMOutput);\n  logger.info('Logger initialized with DOM output', '[TC]');\n\n  // Expose shared DOM output instance globally after creation\n  (window as any).sharedDOMOutput = sharedDOMOutput;\n  // Keep old names for backwards compatibility\n  (window as any).towerDOMOutput = sharedDOMOutput;\n  (window as any).loggerDOMOutput = sharedDOMOutput;\n};\n\n// Initialize logger when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', initializeLogger);\n} else {\n  initializeLogger();\n}\n\n// Expose constants globally for the inline script\n(window as any).TOWER_AUDIO_LIBRARY = TOWER_AUDIO_LIBRARY;\n(window as any).TOWER_LIGHT_SEQUENCES = TOWER_LIGHT_SEQUENCES;\n(window as any).LIGHT_EFFECTS = LIGHT_EFFECTS;\n(window as any).GLYPHS = GLYPHS;\n\n// Expose functions from udtTowerState.ts globally\n(window as any).rtdt_pack_state = rtdt_pack_state;\n(window as any).rtdt_unpack_state = rtdt_unpack_state;\n(window as any).createDefaultTowerState = createDefaultTowerState;\n\n// Expose Tower instance globally so HTML can access batteryNotifyOnValueChangeOnly\n(window as any).Tower = Tower;\n// Expose Tower instance and logger globally\n(window as any).Tower = Tower;\n(window as any).logger = logger;\n\n// skull drop callback\nconst updateSkullDropCount = (count: number) => {\n  const el = document.getElementById(\"skull-count\");\n  if (el) {\n    el.innerText = count.toString();\n  }\n}\nTower.onSkullDrop = updateSkullDropCount;\n\nasync function connectToTower() {\n  logger.info(\"Attempting to connect to tower...\", '[TC]');\n  try {\n    await Tower.connect();\n  } catch (error) {\n    logger.error(`Connection failed: ${error}`, '[TC]');\n  }\n}\n\nconst onTowerConnected = () => {\n  const el = document.getElementById(\"tower-connection-state\");\n  if (el) {\n    el.innerText = \"Tower Connected\"\n    el.style.background = 'rgb(2 255 14 / 30%)';\n  }\n  logger.info(\"Tower connected successfully\", '[TC]');\n\n  // Configure battery notification settings\n  Tower.batteryNotifyFrequency = 1000;\n  // Apply the UI battery filter setting\n  const batteryFilterRadios = document.querySelectorAll('input[name=\"batteryFilter\"]') as NodeListOf<HTMLInputElement>;\n  const selectedValue = Array.from(batteryFilterRadios).find(radio => radio.checked)?.value;\n  if (selectedValue === 'none') {\n    Tower.batteryNotifyEnabled = false;\n  } else {\n    Tower.batteryNotifyEnabled = true;\n    Tower.batteryNotifyOnValueChangeOnly = selectedValue === 'changes';\n  }\n\n  // Initialize battery trend display\n  updateBatteryTrend();\n\n  // Initialize calibration status display\n  updateCalibrationStatus();\n\n  // Initialize drum dropdown positions\n  updateDrumDropdowns();\n\n  // Initialize status packet display\n\n  // Initialize volume display\n  initializeVolumeDisplay();\n  setTimeout(() => {\n    try {\n      if (typeof refreshStatusPacket === 'function') {\n        refreshStatusPacket();\n      }\n    } catch (error) {\n      logger.debug(\"Error initializing status packet: \" + error, '[TC]');\n    }\n  }, 500);\n}\nTower.onTowerConnect = onTowerConnected;\n\nconst onTowerDisconnected = () => {\n  const el = document.getElementById(\"tower-connection-state\");\n  if (el) {\n    el.innerText = \"Tower Disconnected\";\n    el.style.background = 'rgb(255 1 1 / 30%)';\n  }\n  logger.warn(\"Tower disconnected\", '[TC]');\n\n  // Update calibration status for disconnected state\n  updateCalibrationStatus();\n}\nTower.onTowerDisconnect = onTowerDisconnected;\n\nasync function calibrate() {\n  if (!Tower.isConnected) {\n    return;\n  }\n  await Tower.calibrate();\n  const el = document.getElementById(\"calibrating-message\");\n  if (el) {\n    el.classList.remove(\"hidden\");\n  }\n}\n\nconst onCalibrationComplete = () => {\n  const el = document.getElementById(\"calibrating-message\");\n  if (el) {\n    el.classList.add(\"hidden\");\n  }\n\n  // Auto-refresh glyph positions after calibration\n  logger.info(\"Calibration complete\", '[TC]');\n\n  // Note: calibration status will be updated via onTowerStateUpdate callback\n  // when the tower state changes, no need for setTimeout here\n\n  // Wait a bit for calibration to fully complete, then refresh glyph positions and drum dropdowns\n  setTimeout(() => {\n    try {\n      if (typeof (window as any).refreshGlyphPositions === 'function') {\n        (window as any).refreshGlyphPositions();\n        logger.info(\"Glyph positions refreshed after calibration\", '[TC]');\n      } else {\n        logger.warn(\"refreshGlyphPositions function not available\", '[TC]');\n      }\n\n      // Update drum dropdowns after calibration completes\n      updateDrumDropdowns();\n    } catch (error) {\n      logger.error(\"Error refreshing glyph positions after calibration: \" + error, '[TC]');\n    }\n  }, 1500);\n}\nTower.onCalibrationComplete = onCalibrationComplete;\n\nconst updateBatteryTrend = () => {\n  const trendElement = document.getElementById(\"batteryTrend\");\n  if (!trendElement) return;\n\n  const currentBatteryPercent = Tower.currentBatteryPercent;\n  const previousBatteryPercent = Tower.previousBatteryPercent;\n\n  // Skip trend update if we don't have previous data yet\n  if (previousBatteryPercent === 0) {\n    trendElement.innerHTML = '<span style=\"color: #d1d5db; font-size: 16px;\">\u2192</span>';\n    return;\n  }\n\n  if (currentBatteryPercent > previousBatteryPercent) {\n    // Battery increased - green up arrow\n    trendElement.innerHTML = '<span style=\"color: #10b981; font-size: 16px;\">\u2191</span>';\n  } else if (currentBatteryPercent < previousBatteryPercent) {\n    // Battery decreased - yellow down arrow\n    trendElement.innerHTML = '<span style=\"color: #fbbf24; font-size: 16px;\">\u2193</span>';\n  } else {\n    // Battery same - light grey right arrow\n    trendElement.innerHTML = '<span style=\"color: #d1d5db; font-size: 16px;\">\u2192</span>';\n  }\n}\n\nconst onBatteryLevelNotify = (millivolts: number) => {\n  const el = document.getElementById(\"battery\");\n  if (el) {\n    el.innerText = Tower.milliVoltsToPercentage(millivolts).toString();\n  }\n\n  // Update battery trend after battery display is updated\n  updateBatteryTrend();\n}\nTower.onBatteryLevelNotify = onBatteryLevelNotify;\n\nconst onTowerStateUpdate = (newState: TowerState, oldState: TowerState, source: string) => {\n  logger.debug(`Tower state updated from ${source}`, '[TC]');\n\n  // Check if calibration status changed and update the UI accordingly\n  const calibrationChanged =\n    newState.drum[0].calibrated !== oldState.drum[0].calibrated ||\n    newState.drum[1].calibrated !== oldState.drum[1].calibrated ||\n    newState.drum[2].calibrated !== oldState.drum[2].calibrated;\n\n  if (calibrationChanged) {\n    logger.info(\"Calibration status changed, updating display\", '[TC]');\n    updateCalibrationStatus();\n  }\n\n  // Check if drum positions changed and update the dropdowns accordingly\n  const drumPositionsChanged =\n    newState.drum[0].position !== oldState.drum[0].position ||\n    newState.drum[1].position !== oldState.drum[1].position ||\n    newState.drum[2].position !== oldState.drum[2].position;\n\n  if (drumPositionsChanged) {\n    logger.info(\"Drum positions changed, updating dropdowns\", '[TC]');\n    updateDrumDropdowns();\n  }\n\n  // Check if volume changed and update the display (but don't override our local volume tracking)\n  if (newState.audio.volume !== oldState.audio.volume) {\n    logger.info(`Volume changed from ${oldState.audio.volume} to ${newState.audio.volume}`, '[TC]');\n    // Don't let tower responses override our local volume tracking during user-initiated changes\n    // Only sync if there's no recent user interaction or a very large difference\n    logger.debug(`Tower volume: ${newState.audio.volume}, Local volume: ${localVolume}`, '[TC]');\n  }\n\n  // Auto-refresh status packet when tower state changes\n  try {\n    if (typeof refreshStatusPacket === 'function') {\n      refreshStatusPacket();\n    }\n  } catch (error) {\n    logger.debug(\"Error auto-refreshing status packet: \" + error, '[TC]');\n  }\n};\nTower.onTowerStateUpdate = onTowerStateUpdate;\n\nconst updateCalibrationStatus = () => {\n  const topIcon = document.getElementById(\"calibration-top\");\n  const middleIcon = document.getElementById(\"calibration-middle\");\n  const bottomIcon = document.getElementById(\"calibration-bottom\");\n\n  if (!topIcon || !middleIcon || !bottomIcon) {\n    logger.warn(\"Calibration icon elements not found\", '[TC]');\n    return;\n  }\n\n  if (!Tower.isConnected) {\n    // Unknown state - gray question circles\n    topIcon.className = \"fas fa-question-circle text-gray-400 text-lg\";\n    topIcon.title = \"Top drum status unknown\";\n    middleIcon.className = \"fas fa-question-circle text-gray-400 text-lg\";\n    middleIcon.title = \"Middle drum status unknown\";\n    bottomIcon.className = \"fas fa-question-circle text-gray-400 text-lg\";\n    bottomIcon.title = \"Bottom drum status unknown\";\n    return;\n  }\n\n  const towerState = Tower.getCurrentTowerState();\n\n  // Update top drum calibration icon\n  if (towerState.drum[0].calibrated) {\n    topIcon.className = \"fas fa-check-circle text-green-400 text-lg\";\n    topIcon.title = \"Top drum calibrated\";\n  } else {\n    topIcon.className = \"fas fa-times-circle text-red-400 text-lg\";\n    topIcon.title = \"Top drum not calibrated\";\n  }\n\n  // Update middle drum calibration icon\n  if (towerState.drum[1].calibrated) {\n    middleIcon.className = \"fas fa-check-circle text-green-400 text-lg\";\n    middleIcon.title = \"Middle drum calibrated\";\n  } else {\n    middleIcon.className = \"fas fa-times-circle text-red-400 text-lg\";\n    middleIcon.title = \"Middle drum not calibrated\";\n  }\n\n  // Update bottom drum calibration icon\n  if (towerState.drum[2].calibrated) {\n    bottomIcon.className = \"fas fa-check-circle text-green-400 text-lg\";\n    bottomIcon.title = \"Bottom drum calibrated\";\n  } else {\n    bottomIcon.className = \"fas fa-times-circle text-red-400 text-lg\";\n    bottomIcon.title = \"Bottom drum not calibrated\";\n  }\n}\n\nconst updateDrumDropdowns = () => {\n  const topSelect = document.getElementById(\"top\") as HTMLSelectElement;\n  const middleSelect = document.getElementById(\"middle\") as HTMLSelectElement;\n  const bottomSelect = document.getElementById(\"bottom\") as HTMLSelectElement;\n\n  if (!topSelect || !middleSelect || !bottomSelect) {\n    logger.warn(\"Drum dropdown elements not found\", '[TC]');\n    return;\n  }\n\n  if (!Tower.isConnected) {\n    logger.debug(\"Tower not connected, cannot update drum positions\", '[TC]');\n    return;\n  }\n\n  try {\n    // Get current tower state for detailed debugging\n    const towerState = Tower.getCurrentTowerState();\n\n    // Get current drum positions from Tower method (now fixed to use tower state directly)\n    const topPosition = Tower.getCurrentDrumPosition('top');\n    const middlePosition = Tower.getCurrentDrumPosition('middle');\n    const bottomPosition = Tower.getCurrentDrumPosition('bottom');\n\n    // Convert raw position values for comparison logging\n    const sides = ['north', 'east', 'south', 'west'];\n    const topPositionFromRaw = sides[towerState.drum[0].position] || 'north';\n    const middlePositionFromRaw = sides[towerState.drum[1].position] || 'north';\n    const bottomPositionFromRaw = sides[towerState.drum[2].position] || 'north';\n\n    // Verify that the method and raw state match (they should now)\n    if (topPosition !== topPositionFromRaw || middlePosition !== middlePositionFromRaw || bottomPosition !== bottomPositionFromRaw) {\n      logger.warn(`Position mismatch detected! Method vs Raw - Top: ${topPosition}!=${topPositionFromRaw}, Middle: ${middlePosition}!=${middlePositionFromRaw}, Bottom: ${bottomPosition}!=${bottomPositionFromRaw}`, '[TC]');\n    }\n\n    // Update dropdown selections to match current drum positions\n    topSelect.value = topPosition;\n    middleSelect.value = middlePosition;\n    bottomSelect.value = bottomPosition;\n  } catch (error) {\n    logger.error(`Failed to update drum dropdowns: ${error}`, '[TC]');\n  }\n}\n\nasync function resetSkullCount() {\n  if (!Tower.isConnected) {\n    return;\n  }\n  Tower.resetTowerSkullCount();\n  updateSkullDropCount(0);\n}\n\nconst playSound = () => {\n  const select = document.getElementById(\"sounds\") as HTMLInputElement;\n  const soundValue = Number(select.value);\n\n  if (soundValue === 0) {\n    logger.info('No sound selected', '[Audio]');\n    return;\n  }\n\n  // Use the current local volume for playing the sound\n  logger.info(`Playing sound ${soundValue} at volume ${localVolume}`, '[Audio]');\n  Tower.playSoundStateful(soundValue, false, localVolume);\n}\n\nconst overrides = () => {\n  const select = document.getElementById(\"lightOverrideDropDown\") as HTMLInputElement;\n  Tower.lightOverrides(Number(select.value));\n}\n\nconst rotate = () => {\n  const top = document.getElementById(\"top\") as HTMLInputElement;\n  const middle = document.getElementById(\"middle\") as HTMLInputElement;\n  const bottom = document.getElementById(\"bottom\") as HTMLInputElement;\n  Tower.rotateWithState(\n    top.value as TowerSide,\n    middle.value as TowerSide,\n    bottom.value as TowerSide\n  );\n}\n\nconst randomizeLevels = () => {\n  const select = document.getElementById(\"randomLevels\") as HTMLSelectElement;\n  const levelValue = parseInt(select.value);\n\n  if (levelValue === -1) {\n    logger.warn(\"No level selected for randomization\", '[TC]');\n    return;\n  }\n\n  if (!Tower.isConnected) {\n    logger.warn(\"Tower is not connected\", '[TC]');\n    return;\n  }\n\n  Tower.randomRotateLevels(levelValue);\n}\n\nconst breakSeal = async () => {\n  const select = document.getElementById(\"sealSelect\") as HTMLSelectElement;\n  const sealValue = select.value;\n\n  if (!sealValue) {\n    logger.warn(\"No seal selected\", '[TC]');\n    return;\n  }\n\n  // Check if we're in timeout period\n  if (breakSealTimeout !== null) {\n    logger.warn(\"Break seal is in progress. Please wait before breaking another seal.\", '[TC]');\n    return;\n  }\n\n  // Map seal names to SealIdentifier objects\n  const sealMap: { [key: string]: SealIdentifier } = {\n    \"North Top\": { side: 'north', level: 'top' },\n    \"East Top\": { side: 'east', level: 'top' },\n    \"South Top\": { side: 'south', level: 'top' },\n    \"West Top\": { side: 'west', level: 'top' },\n    \"North Middle\": { side: 'north', level: 'middle' },\n    \"East Middle\": { side: 'east', level: 'middle' },\n    \"South Middle\": { side: 'south', level: 'middle' },\n    \"West Middle\": { side: 'west', level: 'middle' },\n    \"North Bottom\": { side: 'north', level: 'bottom' },\n    \"East Bottom\": { side: 'east', level: 'bottom' },\n    \"South Bottom\": { side: 'south', level: 'bottom' },\n    \"West Bottom\": { side: 'west', level: 'bottom' }\n  };\n\n  const sealIdentifier = sealMap[sealValue];\n  if (sealIdentifier) {\n    await Tower.breakSeal(sealIdentifier, localVolume);\n    logger.info(`Broke seal at ${sealIdentifier.level}-${sealIdentifier.side}`, '[TC]');\n\n    // Update the visual seal grid\n    updateSealGrid(sealIdentifier, true);\n\n    // Start cooldown and disable button\n    startBreakSealCooldown();\n  }\n}\n\nconst clearAllLightCheckboxes = async () => {\n  // Unselect all light checkboxes\n  const allLightCheckboxes = document.querySelectorAll('input[type=\"checkbox\"][data-light-type]') as NodeListOf<HTMLInputElement>;\n  allLightCheckboxes.forEach(checkbox => {\n    checkbox.checked = false;\n    checkbox.setAttribute('data-light-style', 'off');\n  });\n\n  // Get current tower state and turn off all lights\n  const currentState = Tower.getCurrentTowerState();\n\n  // Turn off all lights in all layers\n  for (let layerIndex = 0; layerIndex < currentState.layer.length; layerIndex++) {\n    for (let lightIndex = 0; lightIndex < currentState.layer[layerIndex].light.length; lightIndex++) {\n      currentState.layer[layerIndex].light[lightIndex].effect = LIGHT_EFFECTS.off;\n      currentState.layer[layerIndex].light[lightIndex].loop = false;\n    }\n  }\n\n  // Send updated state to tower\n  try {\n    await Tower.sendTowerState(currentState);\n  } catch (error) {\n    console.error('Error sending tower state for all lights off:', error);\n  }\n}\n\nconst allLightsOn = async () => {\n  // Get the currently selected light style from the dropdown\n  const lightStyleSelect = document.getElementById(\"lightStyles\") as HTMLSelectElement;\n  const selectedLightStyle = lightStyleSelect?.options[lightStyleSelect.selectedIndex]?.textContent || \"on\";\n  const effect = LIGHT_EFFECTS[selectedLightStyle as keyof typeof LIGHT_EFFECTS] || LIGHT_EFFECTS.on;\n\n  // Check all light checkboxes and set their style\n  const allLightCheckboxes = document.querySelectorAll('input[type=\"checkbox\"][data-light-type]') as NodeListOf<HTMLInputElement>;\n  allLightCheckboxes.forEach(checkbox => {\n    checkbox.checked = true;\n    checkbox.setAttribute('data-light-style', selectedLightStyle);\n  });\n\n  // Get current tower state and turn on all lights with selected effect\n  const currentState = Tower.getCurrentTowerState();\n\n  // Apply effect to all doorway, ledge, and base lights\n  // Doorway: layers TOP_RING, MIDDLE_RING, BOTTOM_RING (indices 0,1,2)\n  for (let layerIndex = 0; layerIndex <= 2; layerIndex++) {\n    for (let lightIndex = 0; lightIndex < currentState.layer[layerIndex].light.length; lightIndex++) {\n      currentState.layer[layerIndex].light[lightIndex].effect = effect;\n      currentState.layer[layerIndex].light[lightIndex].loop = effect !== 0;\n    }\n  }\n  // Ledge: layer LEDGE (index 3)\n  for (let lightIndex = 0; lightIndex < currentState.layer[3].light.length; lightIndex++) {\n    currentState.layer[3].light[lightIndex].effect = effect;\n    currentState.layer[3].light[lightIndex].loop = effect !== 0;\n  }\n  // Base: layers BASE1 and BASE2 (indices 4,5)\n  for (let layerIndex = 4; layerIndex <= 5; layerIndex++) {\n    for (let lightIndex = 0; lightIndex < currentState.layer[layerIndex].light.length; lightIndex++) {\n      currentState.layer[layerIndex].light[lightIndex].effect = effect;\n      currentState.layer[layerIndex].light[lightIndex].loop = effect !== 0;\n    }\n  }\n\n  // Send updated state to tower\n  try {\n    await Tower.sendTowerState(currentState);\n  } catch (error) {\n    console.error('Error sending tower state for all lights on:', error);\n  }\n}\n\nconst allLightsOff = async () => {\n  // Uncheck all light checkboxes and send tower state\n  await clearAllLightCheckboxes();\n}\n\nconst clearAllLights = async () => {\n  // Clear checkboxes first, before sending tower command\n  await clearAllLightCheckboxes();\n\n  logger.info(\"All lights cleared\", '[TC]');\n\n  // Reset all broken seals and update the visual grid\n  Tower.resetBrokenSeals();\n  resetSealGrid();\n\n  // Reset the dropdown to default selection\n  const sealSelect = document.getElementById(\"sealSelect\") as HTMLSelectElement;\n  if (sealSelect) {\n    sealSelect.value = \"\";\n  }\n}\n\nconst singleLight = async (el: HTMLInputElement) => {\n  // Get the light style based on checkbox state\n  let style: string = \"off\";\n  if (el.checked) {\n    const ls = document.getElementById(\"lightStyles\") as HTMLSelectElement;\n    if (ls && ls.selectedIndex >= 0) {\n      style = ls.options[ls.selectedIndex].innerHTML;\n    }\n  }\n  el.setAttribute('data-light-style', style);\n\n  // Get light effect value\n  const effect = LIGHT_EFFECTS[style as keyof typeof LIGHT_EFFECTS] || LIGHT_EFFECTS.off;\n  console.log('[cek] style =', style, 'effect =', effect);\n\n  // Get current tower state\n  const currentState = Tower.getCurrentTowerState();\n\n  // Get light attributes\n  const lightType = el.getAttribute('data-light-type');\n  const lightLocation = el.getAttribute('data-light-location') as TowerSide;\n  const lightLevel = el.getAttribute('data-light-level') as TowerLevels;\n  const lightBaseLocation = el.getAttribute('data-light-base-location');\n\n  // Calculate layer and light indices\n  let layerIndex: number;\n  let lightIndex: number;\n\n  if (lightType === 'doorway') {\n    // Doorway lights: map level to layer and side to light index\n    layerIndex = getTowerLayerForLevel(lightLevel);\n    lightIndex = getLightIndexForSide(lightLocation);\n  } else if (lightType === 'ledge') {\n    // Ledge lights\n    layerIndex = TOWER_LAYERS.LEDGE;\n    lightIndex = getLedgeLightIndexForSide(lightLocation);\n  } else if (lightType === 'base') {\n    // Base lights: map base location to layer\n    layerIndex = lightBaseLocation === 'b' ? TOWER_LAYERS.BASE2 : TOWER_LAYERS.BASE1;\n    lightIndex = getBaseLightIndexForSide(lightLocation);\n  } else {\n    console.error('Unknown light type:', lightType);\n    return;\n  }\n\n  // Update the specific light in tower state\n  currentState.layer[layerIndex].light[lightIndex].effect = effect;\n  currentState.layer[layerIndex].light[lightIndex].loop = effect !== 0; // loop if not off\n\n  // Send updated state to tower\n  try {\n    await Tower.sendTowerState(currentState);\n  } catch (error) {\n    console.error('Error sending tower state:', error);\n  }\n}\n\n// Helper functions for light mapping (same logic as in udtTowerCommands.ts)\nconst getTowerLayerForLevel = (level: TowerLevels): number => {\n  switch (level) {\n    case 'top': return TOWER_LAYERS.TOP_RING;\n    case 'middle': return TOWER_LAYERS.MIDDLE_RING;\n    case 'bottom': return TOWER_LAYERS.BOTTOM_RING;\n    default: return TOWER_LAYERS.TOP_RING;\n  }\n};\n\nconst getLightIndexForSide = (side: TowerSide): number => {\n  switch (side) {\n    case 'north': return RING_LIGHT_POSITIONS.NORTH;\n    case 'east': return RING_LIGHT_POSITIONS.EAST;\n    case 'south': return RING_LIGHT_POSITIONS.SOUTH;\n    case 'west': return RING_LIGHT_POSITIONS.WEST;\n    default: return RING_LIGHT_POSITIONS.NORTH;\n  }\n};\n\n\nconst getLedgeLightIndexForSide = (side: string): number => {\n  // Map ordinal directions directly to ledge light positions\n  switch (side) {\n    case 'northeast': return LEDGE_BASE_LIGHT_POSITIONS.NORTH_EAST;\n    case 'southeast': return LEDGE_BASE_LIGHT_POSITIONS.SOUTH_EAST;\n    case 'southwest': return LEDGE_BASE_LIGHT_POSITIONS.SOUTH_WEST;\n    case 'northwest': return LEDGE_BASE_LIGHT_POSITIONS.NORTH_WEST;\n    default: return LEDGE_BASE_LIGHT_POSITIONS.NORTH_EAST;\n  }\n};\n\nconst getBaseLightIndexForSide = (side: TowerSide): number => {\n  // Map cardinal directions to ordinal positions for base lights\n  switch (side) {\n    case 'north': return LEDGE_BASE_LIGHT_POSITIONS.NORTH_EAST;  // Closest to north\n    case 'east': return LEDGE_BASE_LIGHT_POSITIONS.SOUTH_EAST;   // Closest to east\n    case 'south': return LEDGE_BASE_LIGHT_POSITIONS.SOUTH_WEST;  // Closest to south\n    case 'west': return LEDGE_BASE_LIGHT_POSITIONS.NORTH_WEST;   // Closest to west\n    default: return LEDGE_BASE_LIGHT_POSITIONS.NORTH_EAST;\n  }\n};\n\nconst lights = () => {\n  // Get the currently selected light style from the dropdown\n  const lightStyleSelect = document.getElementById(\"lightStyles\") as HTMLSelectElement;\n  const selectedLightStyle = lightStyleSelect?.options[lightStyleSelect.selectedIndex]?.textContent || \"off\";\n\n  // Apply the selected style to all checked lights and turn off unchecked lights\n  const allLEDLights = document.querySelectorAll('input[type=\"checkbox\"][data-light-type]') as NodeListOf<HTMLInputElement>;\n  allLEDLights.forEach(checkbox => {\n    if (checkbox.checked) {\n      checkbox.setAttribute('data-light-style', selectedLightStyle);\n    } else {\n      checkbox.setAttribute('data-light-style', 'off');\n    }\n  });\n\n  const doorwayLights: Array<DoorwayLight> = getDoorwayLights();\n  const ledgeLights: Array<LedgeLight> = getLedgeLights();\n  const baseLights: Array<BaseLight> = getBaseLights();\n  const allLights = { doorway: doorwayLights, ledge: ledgeLights, base: baseLights };\n  Tower.Lights(allLights);\n}\n\nconst getDoorwayLights = (): Array<DoorwayLight> => {\n  const qs = 'input[type=\"checkbox\"][data-light-type=\"doorway\"]:checked'\n  const checked = document.querySelectorAll(qs) as NodeListOf<HTMLInputElement>;\n  const ls = document.getElementById(\"lightStyles\") as HTMLSelectElement;\n  const selectedLightStyle = ls?.options[ls.selectedIndex]?.textContent || \"off\";\n  let doorwayCmds: Array<DoorwayLight> = [];\n  Array.from(checked).forEach(cb => {\n    let { lightSide, lightStyle, lightLevel } = getDataAttributes(cb);\n    if (lightStyle !== selectedLightStyle) {\n      lightStyle = selectedLightStyle;\n      cb.setAttribute('data-light-style', lightStyle);\n    }\n    if (lightSide && lightLevel && lightStyle) {\n      doorwayCmds.push({ position: lightSide as TowerSide, level: lightLevel as TowerLevels, style: lightStyle });\n    }\n  });\n  return doorwayCmds;\n}\n\nconst getLedgeLights = (): Array<LedgeLight> => {\n  const qs = 'input[type=\"checkbox\"][data-light-type=\"ledge\"]:checked';\n  const checked = document.querySelectorAll(qs) as NodeListOf<HTMLInputElement>;\n  let ledgeCmds: Array<LedgeLight> = [];\n  Array.from(checked).forEach(cb => {\n    const { lightSide, lightStyle } = getDataAttributes(cb);\n    if (lightSide && lightStyle) {\n      ledgeCmds.push({ position: lightSide as TowerCorner, style: lightStyle });\n    }\n  });\n  return ledgeCmds;\n}\n\nconst getBaseLights = (): Array<BaseLight> => {\n  const qs = 'input[type=\"checkbox\"][data-light-type=\"base\"]:checked';\n  const checked = document.querySelectorAll(qs) as NodeListOf<HTMLInputElement>;\n  let baseCmds: Array<BaseLight> = [];\n  Array.from(checked).forEach(cb => {\n    const { lightSide, lightStyle, lightBaseLocation } = getDataAttributes(cb);\n    if (lightSide && lightStyle && lightBaseLocation) {\n      baseCmds.push({\n        position: {\n          side: lightSide as TowerSide,\n          level: lightBaseLocation as BaseLightLevel\n        },\n        style: lightStyle\n      });\n    }\n  });\n\n  return baseCmds;\n}\n\nconst getDataAttributes = (el: HTMLElement) => {\n  const lightType = el.getAttribute('data-light-type');\n  const lightSide = el.getAttribute('data-light-location');\n  const lightLevel = el.getAttribute('data-light-level');\n  const lightBaseLocation = el.getAttribute('data-light-base-location');\n  const lightStyle = el.getAttribute('data-light-style');\n\n  return ({\n    lightSide: lightSide,\n    lightLevel: lightLevel,\n    lightBaseLocation: lightBaseLocation,\n    lightStyle: lightStyle,\n    lightType: lightType,\n  });\n}\n\n/**\n * Updates the visual representation of a specific seal in the grid\n * @param seal - The seal to update\n * @param isBroken - Whether the seal is broken or not\n */\nconst updateSealGrid = (seal: SealIdentifier, isBroken: boolean) => {\n  const sealSquare = document.querySelector(`[data-seal-level=\"${seal.level}\"][data-seal-side=\"${seal.side}\"]`) as HTMLElement;\n  if (sealSquare) {\n    if (isBroken) {\n      sealSquare.classList.add('broken');\n    } else {\n      sealSquare.classList.remove('broken');\n    }\n  }\n}\n\n/**\n * Resets all seals in the visual grid to their default (unbroken) state\n */\nconst resetSealGrid = () => {\n  const allSealSquares = document.querySelectorAll('.seal-square') as NodeListOf<HTMLElement>;\n  allSealSquares.forEach(square => {\n    square.classList.remove('broken');\n  });\n}\n\n// Global variable to track break seal timeout\nlet breakSealTimeout: number | null = null;\n\n/**\n * Starts the break seal cooldown and manages button state\n */\nconst startBreakSealCooldown = () => {\n  const breakSealButton = document.getElementById(\"breakSealButton\") as HTMLButtonElement;\n\n  // Disable the button and update text\n  if (breakSealButton) {\n    breakSealButton.disabled = true;\n    breakSealButton.style.opacity = \"0.5\";\n  }\n\n  // Start 10-second timeout\n  logger.info(\"Break seal cooldown started (10 seconds)\", '[TC]');\n  breakSealTimeout = window.setTimeout(() => {\n    breakSealTimeout = null;\n\n    // Re-enable the button and restore text\n    if (breakSealButton) {\n      breakSealButton.disabled = false;\n      breakSealButton.textContent = \"Break Seal\";\n      breakSealButton.style.opacity = \"1\";\n    }\n\n    logger.info(\"Break seal cooldown ended\", '[TC]');\n  }, 10000);\n}\n\n/**\n * Handles clicks on seal squares in the grid\n * @param element - The clicked seal square element\n */\nconst sealSquareClick = (element: HTMLElement) => {\n  const level = element.getAttribute('data-seal-level');\n  const side = element.getAttribute('data-seal-side');\n\n  if (!level || !side) {\n    logger.warn(\"Invalid seal square data\", '[TC]');\n    return;\n  }\n\n  const sealSelect = document.getElementById(\"sealSelect\") as HTMLSelectElement;\n  const isCurrentlyBroken = element.classList.contains('broken');\n\n  if (isCurrentlyBroken) {\n    // Seal is already broken - reset it (no timeout needed for resets)\n    element.classList.remove('broken');\n\n    // Remove from Tower's broken seals tracking\n    const sealKey = `${level}-${side}`;\n    (Tower as any).brokenSeals.delete(sealKey);\n\n    // Reset dropdown to default\n    if (sealSelect) {\n      sealSelect.value = \"\";\n    }\n\n    logger.info(`Reset seal at ${level}-${side}`, '[TC]');\n  } else {\n    // Seal is not broken - check if we're in timeout period\n    if (breakSealTimeout !== null) {\n      logger.warn(\"Break seal is on cooldown. Please wait before breaking another seal.\", '[TC]');\n      return;\n    }\n\n    // Break the seal\n    // Capitalize first letter for dropdown value format\n    const capitalizeFirst = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n    const dropdownValue = `${capitalizeFirst(side)} ${capitalizeFirst(level)}`;\n\n    // Update the dropdown selection\n    if (sealSelect) {\n      sealSelect.value = dropdownValue;\n    }\n\n    // Trigger the break seal function\n    breakSeal();\n  }\n}\n\n// Tab switching functionality\nconst switchTab = (tabName: string) => {\n  // Turn off all lights when switching tabs\n  allLightsOff();\n\n  // Hide all tab contents\n  const allTabContents = document.querySelectorAll('.tower-tab-content');\n  allTabContents.forEach(content => {\n    content.classList.remove('tower-tab-content-active');\n  });\n\n  // Remove active class from all tab buttons\n  const allTabButtons = document.querySelectorAll('.tower-tab-button');\n  allTabButtons.forEach(button => {\n    button.classList.remove('tower-tab-active');\n  });\n\n  // Show selected tab content\n  const selectedContent = document.getElementById(`${tabName}-content`);\n  if (selectedContent) {\n    selectedContent.classList.add('tower-tab-content-active');\n  }\n\n  // Add active class to selected tab button\n  const selectedButton = document.getElementById(`${tabName}-tab`);\n  if (selectedButton) {\n    selectedButton.classList.add('tower-tab-active');\n  }\n}\n\n// Glyph management functionality with light tracking\nconst moveGlyph = async () => {\n  const glyphSelect = document.getElementById('glyph-select') as HTMLSelectElement;\n  const sideSelect = document.getElementById('side-select') as HTMLSelectElement;\n\n  const selectedGlyph = glyphSelect.value;\n  const targetSide = sideSelect.value;\n\n  logger.debug(`UI Selection: glyph=${selectedGlyph}, targetSide=${targetSide}`, '[Glyphs]');\n\n  if (!selectedGlyph || !targetSide) {\n    logger.warn('Please select a glyph and target side', '[Glyphs]');\n    return;\n  }\n\n  try {\n    // Get current glyph position directly (more reliable than getAllGlyphPositions)\n    const currentGlyphPosition = Tower.getGlyphPosition(selectedGlyph as Glyphs);\n\n    if (!currentGlyphPosition) {\n      logger.error(`Unable to find current position for ${selectedGlyph} glyph, please perform a calibration first.`, '[Glyphs]');\n      return;\n    }\n\n    // Get the fixed level for this glyph (glyphs can't change levels)\n    const glyphLevel = GLYPHS[selectedGlyph as keyof typeof GLYPHS].level;\n\n    // Calculate rotation needed to move glyph to target position\n    const sides = ['north', 'east', 'south', 'west'];\n    const currentSideIndex = sides.indexOf(currentGlyphPosition);\n    const targetSideIndex = sides.indexOf(targetSide);\n\n    if (currentSideIndex === -1 || targetSideIndex === -1) {\n      logger.error('Invalid current or target side', '[Glyphs]');\n      return;\n    }\n\n    // Calculate clockwise rotation steps needed\n    let rotationSteps = (targetSideIndex - currentSideIndex + 4) % 4;\n\n    if (rotationSteps === 0) {\n      logger.info(`${selectedGlyph} glyph is already at ${targetSide} position`, '[Glyphs]');\n      return;\n    }\n\n    // Calculate what drum position will put the selected glyph at the target side\n    let targetDrumPosition;\n    if (glyphLevel === 'top' || glyphLevel === 'middle' || glyphLevel === 'bottom') {\n      // Calculate the drum position needed to put this specific glyph at the target side\n      const currentDrumPosition = Tower.getCurrentDrumPosition(glyphLevel);\n      const sides = ['north', 'east', 'south', 'west'];\n\n      const currentDrumIndex = sides.indexOf(currentDrumPosition);\n      const currentGlyphIndex = sides.indexOf(currentGlyphPosition);\n      const targetGlyphIndex = sides.indexOf(targetSide);\n\n      // Debug logging to understand the calculation\n      logger.debug(`Move calculation: glyph=${selectedGlyph}, currentGlyphPos=${currentGlyphPosition}, targetSide=${targetSide}, currentDrumPos=${currentDrumPosition}`, '[Glyphs]');\n\n      // Calculate how many steps the glyph needs to move\n      let glyphSteps = (targetGlyphIndex - currentGlyphIndex + 4) % 4;\n\n      // Calculate the new drum position\n      const newDrumIndex = (currentDrumIndex + glyphSteps) % 4;\n      targetDrumPosition = sides[newDrumIndex];\n\n      logger.debug(`Move calculation result: glyphSteps=${glyphSteps}, newDrumIndex=${newDrumIndex}, targetDrumPosition=${targetDrumPosition}`, '[Glyphs]');\n    }\n\n    // Set positions for all three drums\n    const topPosition = glyphLevel === 'top' ? targetDrumPosition : Tower.getCurrentDrumPosition('top');\n    const middlePosition = glyphLevel === 'middle' ? targetDrumPosition : Tower.getCurrentDrumPosition('middle');\n    const bottomPosition = glyphLevel === 'bottom' ? targetDrumPosition : Tower.getCurrentDrumPosition('bottom');\n\n    logger.info(`Moving ${selectedGlyph} glyph from ${currentGlyphPosition} to ${targetSide} by rotating ${glyphLevel} level (${rotationSteps} steps clockwise)`, '[Glyphs]');\n\n    // Execute the rotation with all three drum positions\n    await Tower.rotateWithState(topPosition as TowerSide, middlePosition as TowerSide, bottomPosition as TowerSide);\n\n    // Restore lights after rotation\n    // Wait a moment for rotation to complete, then restore all lights and refresh UI\n    setTimeout(async () => {\n      try {\n        // Refresh glyph positions (this will also restore visual light states based on glyph tracking)\n        refreshGlyphPositions();\n\n        // Restore all lights on the physical tower based on current glyph positions\n        const allDoorwayLights = getCurrentDoorwayLights();\n        if (allDoorwayLights.length > 0) {\n          logger.info(`About to restore ${allDoorwayLights.length} lights: ${JSON.stringify(allDoorwayLights)}`, '[Glyphs]');\n          await Tower.Lights({ doorway: allDoorwayLights });\n          logger.info(`Successfully restored ${allDoorwayLights.length} lights after glyph movement`, '[Glyphs]');\n        } else {\n          logger.warn('No lights to restore after glyph movement', '[Glyphs]');\n        }\n      } catch (error) {\n        logger.error('Error restoring lights after glyph move: ' + error, '[Glyphs]');\n      }\n    }, 1000);\n\n    logger.info(`Successfully moved ${selectedGlyph} glyph to ${targetSide} position`, '[Glyphs]');\n\n  } catch (error) {\n    console.error('Error moving glyph:', error);\n    logger.error('Error moving glyph: ' + error, '[Glyphs]');\n  }\n}\n\n\nconst refreshGlyphPositions = () => {\n  if (!Tower.isConnected) {\n    logger.warn(\"Tower is not connected\", '[TC]');\n    return;\n  }\n\n  try {\n    // Get current glyph positions from tower\n    const positions = Tower.getAllGlyphPositions();\n\n    // Clear all existing glyph displays\n    const allGlyphCells = document.querySelectorAll('.glyph-cell');\n    allGlyphCells.forEach(cell => {\n      cell.innerHTML = '';\n      cell.classList.remove('glyph-lit');\n    });\n\n    // Update display with current positions\n    Object.entries(positions).forEach(([glyphName, side]) => {\n      if (side) {\n        // Get the level from the GLYPHS constant since getAllGlyphPositions only returns the side\n        const glyphLevel = GLYPHS[glyphName as keyof typeof GLYPHS].level;\n        const cellId = `glyph-${glyphLevel}-${side}`;\n        const cell = document.getElementById(cellId);\n        if (cell) {\n          // Add glyph icon\n          const img = document.createElement('img');\n          img.src = `../assets/glyph_${glyphName}.svg`;\n          img.alt = glyphName;\n          cell.appendChild(img);\n        }\n      }\n    });\n\n    // Restore visual light states based on glyph light tracking\n    // Add glyph-lit class to any glyph that has a light\n    for (const glyphName of glyphLightStates) {\n      const currentPosition = Tower.getGlyphPosition(glyphName as any);\n      if (currentPosition) {\n        const level = GLYPHS[glyphName as keyof typeof GLYPHS].level;\n        const cellId = `glyph-${level}-${currentPosition}`;\n        const cell = document.getElementById(cellId);\n        if (cell && cell.querySelector('img')) { // Only if cell has a glyph (img element)\n          cell.classList.add('glyph-lit');\n        }\n      }\n    }\n\n    logger.info(\"Glyph positions refreshed\", '[TC]');\n  } catch (error) {\n    logger.error(`Failed to refresh glyph positions: ${error}`, '[TC]');\n  }\n}\n\n// Log filtering functionality\nconst filterLogs = () => {\n  if (!sharedDOMOutput) {\n    logger.warn(\"DOM output not initialized\", '[TC]');\n    return;\n  }\n\n  const filterSelect = document.getElementById('logFilter') as HTMLSelectElement;\n  const selectedLevel = filterSelect?.value || 'all';\n\n  // Use refreshFilter method instead of setFilter\n  sharedDOMOutput.refreshFilter();\n  logger.info(`Log filter set to: ${selectedLevel}`, '[TC]');\n}\n\nconst clearLogs = () => {\n  if (!sharedDOMOutput) {\n    logger.warn(\"DOM output not initialized\", '[TC]');\n    return;\n  }\n\n  sharedDOMOutput.clearAll();\n  logger.info(\"Logs cleared\", '[TC]');\n}\n\n// Battery filter functionality\nconst updateBatteryFilter = () => {\n  const batteryFilterRadios = document.querySelectorAll('input[name=\"batteryFilter\"]') as NodeListOf<HTMLInputElement>;\n  const selectedValue = Array.from(batteryFilterRadios).find(radio => radio.checked)?.value;\n\n  if (selectedValue) {\n    if (selectedValue === 'none') {\n      Tower.batteryNotifyEnabled = false;\n    } else {\n      Tower.batteryNotifyEnabled = true;\n      Tower.batteryNotifyOnValueChangeOnly = selectedValue === 'changes';\n    }\n    logger.info(`Battery logging set to: ${selectedValue}`, '[TC]');\n  }\n}\n\n// State management functionality\nconst saveState = () => {\n  if (!Tower.isConnected) {\n    logger.warn(\"Tower is not connected\", '[TC]');\n    return;\n  }\n\n  try {\n    const state = Tower.getCurrentTowerState();\n    if (!state) {\n      logger.warn(\"No current tower state available\", '[TC]');\n      return;\n    }\n\n    // Create a buffer for the packed state\n    const buffer = new Uint8Array(256); // Adjust size as needed\n    const success = rtdt_pack_state(buffer, buffer.length, state);\n\n    if (!success) {\n      logger.error(\"Failed to pack tower state\", '[TC]');\n      return;\n    }\n\n    // Convert buffer to array for JSON serialization\n    const packedState = Array.from(buffer);\n\n    // Save to localStorage\n    localStorage.setItem('towerState', JSON.stringify(packedState));\n\n    // Update UI display\n    const stateDisplay = document.getElementById('currentState') as HTMLTextAreaElement;\n    if (stateDisplay) {\n      stateDisplay.value = JSON.stringify(packedState, null, 2);\n    }\n\n    logger.info(\"Tower state saved\", '[TC]');\n  } catch (error) {\n    logger.error(`Failed to save state: ${error}`, '[TC]');\n  }\n}\n\nconst loadState = async () => {\n  if (!Tower.isConnected) {\n    logger.warn(\"Tower is not connected\", '[TC]');\n    return;\n  }\n\n  try {\n    const savedState = localStorage.getItem('towerState');\n    if (!savedState) {\n      logger.warn(\"No saved state found\", '[TC]');\n      return;\n    }\n\n    const packedState = JSON.parse(savedState) as number[];\n    const buffer = new Uint8Array(packedState);\n    const state = rtdt_unpack_state(buffer);\n\n    if (!state) {\n      logger.error(\"Failed to unpack tower state\", '[TC]');\n      return;\n    }\n\n    // Send the state to the tower\n    await Tower.sendTowerState(state);\n    logger.info(\"Tower state loaded\", '[TC]');\n\n    // Refresh displays\n    if (typeof refreshGlyphPositions === 'function') {\n      refreshGlyphPositions();\n    }\n  } catch (error) {\n    logger.error(`Failed to load state: ${error}`, '[TC]');\n  }\n}\n\nconst resetState = async () => {\n  if (!Tower.isConnected) {\n    logger.warn(\"Tower is not connected\", '[TC]');\n    return;\n  }\n\n  try {\n    // Create a default/empty tower state using the utility function\n    const defaultState = createDefaultTowerState();\n\n    // Send the default state to the tower\n    await Tower.sendTowerState(defaultState);\n\n    // Clear saved state\n    localStorage.removeItem('towerState');\n\n    // Clear UI display\n    const stateDisplay = document.getElementById('currentState') as HTMLTextAreaElement;\n    if (stateDisplay) {\n      stateDisplay.value = '';\n    }\n\n    // Reset visual elements\n    resetSealGrid();\n\n    // Refresh displays\n    if (typeof refreshGlyphPositions === 'function') {\n      refreshGlyphPositions();\n    }\n\n    logger.info(\"Tower state reset\", '[TC]');\n  } catch (error) {\n    logger.error(`Failed to reset state: ${error}`, '[TC]');\n  }\n}\n\n// Initialize dropdowns and UI elements\nconst initializeUI = () => {\n  // Populate sound dropdown\n  const soundSelect = document.getElementById('sounds') as HTMLSelectElement;\n  if (soundSelect) {\n    Object.entries(TOWER_AUDIO_LIBRARY).forEach(([key, value]) => {\n      const option = document.createElement('option');\n      option.value = value.value.toString();\n      option.textContent = value.name;\n      soundSelect.appendChild(option);\n    });\n  }\n\n  // Populate light styles dropdown (Apply to all lights - should have basic 6 options)\n  const lightStyleSelect = document.getElementById('lightStyles') as HTMLSelectElement;\n  if (lightStyleSelect) {\n    Object.entries(LIGHT_EFFECTS).forEach(([key, value]) => {\n      const option = document.createElement('option');\n      option.value = key;\n      option.textContent = key; // Use the key (name) for display instead of numeric value\n      lightStyleSelect.appendChild(option);\n    });\n    // Set default selection to 'on' if available\n    const onIndex = Array.from(lightStyleSelect.options).findIndex(opt => opt.value === 'on');\n    if (onIndex >= 0) {\n      lightStyleSelect.selectedIndex = onIndex;\n    }\n  }\n\n  // Populate light overrides dropdown (should have advanced sequences)\n  const lightOverrideSelect = document.getElementById('lightOverrideDropDown') as HTMLSelectElement;\n  if (lightOverrideSelect) {\n    Object.entries(TOWER_LIGHT_SEQUENCES).forEach(([key, value]) => {\n      const option = document.createElement('option');\n      option.value = value.toString(); // Use the numeric value, not the key\n      option.textContent = key;\n      lightOverrideSelect.appendChild(option);\n    });\n  }\n\n  // Set up event listeners for battery filter radio buttons\n  const batteryFilterRadios = document.querySelectorAll('input[name=\"batteryFilter\"]') as NodeListOf<HTMLInputElement>;\n  batteryFilterRadios.forEach(radio => {\n    radio.addEventListener('change', updateBatteryFilter);\n  });\n\n  // Initialize calibration status display\n  updateCalibrationStatus();\n}\n\n// Initialize UI when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', initializeUI);\n} else {\n  initializeUI();\n}\n\n// LED Testing Functions\nconst sendLEDTestCommand = async () => {\n  try {\n    // Get the selected effect and loop setting\n    const effectSelect = document.getElementById('led-effect-select') as HTMLSelectElement;\n    const loopCheckbox = document.getElementById('led-loop-checkbox') as HTMLInputElement;\n    const selectedEffect = parseInt(effectSelect.value);\n    const loopEnabled = loopCheckbox.checked;\n\n    // Get all checked LED checkboxes\n    const checkedLEDs = document.querySelectorAll('.led-checkbox:checked') as NodeListOf<HTMLInputElement>;\n\n    if (checkedLEDs.length === 0) {\n      logger.warn('No LEDs selected for testing', '[LED Testing]');\n      return;\n    }\n\n    if (!Tower || !Tower.getCurrentTowerState || !Tower.sendTowerState) {\n      logger.error('Tower not connected or tower state methods not available', '[LED Testing]');\n      return;\n    }\n\n    // Get current tower state or create a default state\n    let currentState = Tower.getCurrentTowerState();\n    if (!currentState) {\n      // Create default state if none available\n      currentState = createDefaultTowerState();\n    }\n\n    // Apply all LED changes to the tower state\n    checkedLEDs.forEach(checkbox => {\n      const layer = parseInt(checkbox.dataset.layer!);\n      const position = parseInt(checkbox.dataset.position!);\n      const isValidLightPosition = layer >= 0 && layer < 6 && position >= 0 && position < 4;\n\n      if (isValidLightPosition) {\n        currentState.layer[layer].light[position].effect = selectedEffect;\n        currentState.layer[layer].light[position].loop = loopEnabled;\n        logger.debug(`LED configured: layer=${layer}, position=${position}, effect=${selectedEffect}, loop=${loopEnabled}`, '[LED Testing]');\n      }\n    });\n\n    // Send the complete updated tower state in a single command\n    await Tower.sendTowerState(currentState);\n    logger.info(`LED test command sent: ${checkedLEDs.length} LEDs updated, effect=${selectedEffect}, loop=${loopEnabled}`, '[LED Testing]');\n\n  } catch (error) {\n    console.error('Error sending LED test command:', error);\n    logger.error('Error sending LED test command: ' + error, '[LED Testing]');\n  }\n};\n\nconst clearAllLEDs = async () => {\n  try {\n    if (!Tower || !Tower.getCurrentTowerState || !Tower.sendTowerState) {\n      logger.error('Tower not connected or tower state methods not available', '[LED Testing]');\n      return;\n    }\n\n    // Get current tower state or create a default state\n    let currentState = Tower.getCurrentTowerState();\n    if (!currentState) {\n      // Create default state if none available\n      currentState = createDefaultTowerState();\n    }\n\n    // Turn off all LEDs in the tower state\n    for (let layer = 0; layer < 6; layer++) {\n      for (let position = 0; position < 4; position++) {\n        currentState.layer[layer].light[position].effect = 0; // Effect 0 = off\n        currentState.layer[layer].light[position].loop = false;\n      }\n    }\n\n    // Send the complete updated tower state in a single command\n    await Tower.sendTowerState(currentState);\n    logger.info('All LEDs cleared with single tower state command', '[LED Testing]');\n\n    // Clear all checkboxes\n    document.querySelectorAll('.led-checkbox').forEach(checkbox => {\n      (checkbox as HTMLInputElement).checked = false;\n    });\n\n  } catch (error) {\n    console.error('Error clearing LEDs:', error);\n    logger.error('Error clearing LEDs: ' + error, '[LED Testing]');\n  }\n};\n\n// Log control functions\nconst updateLogLevel = () => {\n  if ((window as any).logger) {\n    const checkboxes = document.querySelectorAll('input[id^=\"logLevel-\"]') as NodeListOf<HTMLInputElement>;\n    const selectedLevels = Array.from(checkboxes)\n      .filter(checkbox => checkbox.checked)\n      .map(checkbox => checkbox.value);\n\n    if (selectedLevels.length > 0) {\n      (window as any).logger.setEnabledLevels(selectedLevels);\n    } else {\n      // Default to 'all' if nothing is selected\n      (window as any).logger.setEnabledLevels(['all']);\n    }\n  }\n\n  // Refresh DOM output filtering (includes text filter)\n  if (sharedDOMOutput) {\n    sharedDOMOutput.refreshFilter();\n  }\n}\n\nconst clearLog = () => {\n  // Clear shared DOM output\n  if (sharedDOMOutput) {\n    sharedDOMOutput.clearAll();\n  }\n\n  // Fallback to direct container clearing\n  const container = document.getElementById(\"log-container\");\n  if (container) {\n    container.innerHTML = '';\n  }\n\n  // Clear the text filter input\n  const textFilter = document.getElementById(\"logTextFilter\") as HTMLInputElement;\n  if (textFilter) {\n    textFilter.value = '';\n  }\n}\n\nconst copyDisplayedLogs = (event: Event) => {\n  const logContainer = document.getElementById(\"log-container\");\n  if (!logContainer) return;\n\n  // Get all currently displayed log entries\n  const logLines = logContainer.querySelectorAll('.log-line');\n  if (logLines.length === 0) {\n    alert('No log entries to copy');\n    return;\n  }\n\n  // Extract text content from each log line\n  const logText = Array.from(logLines)\n    .map(line => line.textContent || '')\n    .join('\\n');\n\n  // Copy to clipboard\n  navigator.clipboard.writeText(logText).then(() => {\n    // Optional: Show temporary success feedback\n    const button = (event.target as HTMLElement).closest('button');\n    if (button) {\n      const originalIcon = button.innerHTML;\n      button.innerHTML = '<i class=\"fas fa-check\"></i>';\n      button.style.backgroundColor = '#10b981';\n\n      setTimeout(() => {\n        button.innerHTML = originalIcon;\n        button.style.backgroundColor = '';\n      }, 1000);\n    }\n  }).catch(err => {\n    console.error('Failed to copy logs: ', err);\n    alert('Failed to copy logs to clipboard');\n  });\n}\n\nconst downloadDisplayedLogs = (event: Event) => {\n  const logContainer = document.getElementById(\"log-container\");\n  if (!logContainer) return;\n\n  // Get all currently displayed log entries\n  const logLines = logContainer.querySelectorAll('.log-line');\n  if (logLines.length === 0) {\n    alert('No log entries to download');\n    return;\n  }\n\n  // Extract text content from each log line\n  const logText = Array.from(logLines)\n    .map(line => line.textContent || '')\n    .join('\\n');\n\n  // Create header with current date and time\n  const now = new Date();\n  const dateStr = now.toLocaleDateString();\n  const timeStr = now.toLocaleTimeString();\n  const header = `UltimateDarkTower Log Output - ${dateStr} ${timeStr}\\n${'-'.repeat(60)}\\n`;\n\n  // Combine header with log content\n  const fileContent = header + logText;\n\n  // Create a blob with the log content\n  const blob = new Blob([fileContent], { type: 'text/plain' });\n  const url = window.URL.createObjectURL(blob);\n\n  // Create a temporary anchor element for download\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = 'TowerLog.txt';\n  document.body.appendChild(a);\n  a.click();\n  document.body.removeChild(a);\n  window.URL.revokeObjectURL(url);\n\n  // Show temporary success feedback\n  const button = (event.target as HTMLElement).closest('button');\n  if (button) {\n    const originalIcon = button.innerHTML;\n    button.innerHTML = '<i class=\"fas fa-check\"></i>';\n    button.style.backgroundColor = '#10b981';\n\n    setTimeout(() => {\n      button.innerHTML = originalIcon;\n      button.style.backgroundColor = '';\n    }, 1000);\n  }\n}\n\n// Tower Status Packet functions\nconst STATE_BUFFER_SIZE = 19;\nconst DISPLAY_BUFFER_SIZE = 20;\nconst EMPTY_STATUS_PACKET = new Array(DISPLAY_BUFFER_SIZE).fill(0);\n\nconst refreshStatusPacket = () => {\n  if (!Tower.isConnected) {\n    logger.warn(\"Tower is not connected\", '[Status Packet]');\n    updateStatusPacketDisplay(EMPTY_STATUS_PACKET);\n    return;\n  }\n\n  try {\n    const state = Tower.getCurrentTowerState();\n    if (!state) {\n      logger.warn(\"No current tower state available\", '[Status Packet]');\n      updateStatusPacketDisplay(EMPTY_STATUS_PACKET);\n      return;\n    }\n\n    // Create a buffer for the packed state (19 bytes + 1 command byte = 20 bytes)\n    const buffer = new Uint8Array(DISPLAY_BUFFER_SIZE);\n    const stateBuffer = new Uint8Array(STATE_BUFFER_SIZE);\n\n    // convert tower state to packet\n    const success = rtdt_pack_state(stateBuffer, STATE_BUFFER_SIZE, state);\n\n    if (!success) {\n      logger.error(\"Failed to pack tower state\", '[Status Packet]');\n      updateStatusPacketDisplay(EMPTY_STATUS_PACKET);\n      return;\n    }\n\n    // Command byte (0x00) + 19 bytes of state data\n    buffer[0] = 0; // Command type for tower state\n    for (let i = 0; i < STATE_BUFFER_SIZE; i++) {\n      buffer[i + 1] = stateBuffer[i];\n    }\n\n    // Convert to array for display\n    const packedState = Array.from(buffer);\n    updateStatusPacketDisplay(packedState);\n\n  } catch (error) {\n    logger.error(`Failed to refresh status packet: ${error}`, '[TC]');\n    updateStatusPacketDisplay(EMPTY_STATUS_PACKET);\n  }\n}\n\nconst updateStatusPacketDisplay = (packetData: number[]) => {\n  const display = document.getElementById('status-packet-display');\n  if (!display) return;\n\n  // Descriptions for each byte position\n  const byteDescriptions = [\n    'Battery Level',\n    'Calibration Status',\n    'Drum Positions (Top)',\n    'Drum Positions (Middle)',\n    'Drum Positions (Bottom)',\n    'Light States (Doorways)',\n    'Light States (Ledges)',\n    'Light States (Base)',\n    'Glyph Positions',\n    'Seal States',\n    'Sound Effects',\n    'Player Count',\n    'Game State',\n    'Error Flags',\n    'Communication Status',\n    'Reserved',\n    'Extended Flags',\n    'Skull Drop Count',\n    'Reserved',\n    'Checksum'\n  ];\n\n  // Clear existing content\n  display.innerHTML = '';\n\n  // Add each byte as a styled span\n  packetData.forEach((byte, index) => {\n    const span = document.createElement('span');\n    span.className = 'status-byte';\n\n    // Add non-zero class for non-zero values\n    if (byte !== 0) {\n      span.className += ' non-zero';\n    }\n\n    span.textContent = byte.toString(16).padStart(2, '0').toUpperCase();\n    const description = index < byteDescriptions.length ? byteDescriptions[index] : 'Unknown';\n    span.title = `Byte ${index}: ${byte}D - ${description}`;\n    display.appendChild(span);\n  });\n}\n\n// Enhanced glyph management functions\nconst getGlyphsFacingDirection = (direction: TowerSide) => {\n  try {\n    return Tower.getGlyphsFacingDirection(direction);\n  } catch (error) {\n    console.error('Error getting glyphs facing direction:', error);\n    logger.error('Error getting glyphs facing direction: ' + error, '[TC]');\n    return [];\n  }\n};\n\n// Light state tracking - keeps track of which glyphs have lights\nconst glyphLightStates = new Set(); // Set of glyph names that have lights on\n\n// Helper function to get current doorway lights based on glyph positions and states\nconst getCurrentDoorwayLights = (): Array<DoorwayLight> => {\n  const doorwayLights: Array<DoorwayLight> = [];\n\n  for (const glyphName of glyphLightStates) {\n    const currentPosition = Tower.getGlyphPosition(glyphName as any);\n\n    if (currentPosition) {\n      const level = GLYPHS[glyphName as keyof typeof GLYPHS].level;\n      const lightCommand: DoorwayLight = {\n        position: currentPosition,\n        level: level as TowerLevels,\n        style: 'on'\n      };\n      doorwayLights.push(lightCommand);\n    } else {\n      logger.warn(`Could not get position for glyph ${glyphName}`, '[TC]');\n    }\n  }\n\n  return doorwayLights;\n};\n\n// Enhanced toggle glyph light function with full functionality\nconst toggleGlyphLight = async (element: HTMLElement) => {\n  const level = element.getAttribute('data-level');\n  const side = element.getAttribute('data-side');\n  const position = `${level}-${side}`;\n\n  // Find which glyph is at this position (if any)\n  const glyphAtPosition = findGlyphAtPosition(level!, side!);\n\n  // Only proceed with lighting effects if there's a glyph at this position\n  if (!glyphAtPosition) {\n    // No glyph at this position, just update the side dropdown\n    const sideSelect = document.getElementById('side-select') as HTMLSelectElement;\n    if (sideSelect) {\n      sideSelect.value = side!;\n    }\n    return; // Exit early, no lighting effects\n  }\n\n  // Toggle the light state (only if glyph is present)\n  const isLit = element.classList.toggle('glyph-lit');\n\n  // Auto-select dropdowns based on clicked glyph\n  const glyphSelect = document.getElementById('glyph-select') as HTMLSelectElement;\n  if (glyphSelect) {\n    glyphSelect.value = glyphAtPosition;\n  }\n\n  // Auto-select the glyph's current position in the side dropdown\n  const glyphCurrentSide = Tower.getGlyphPosition(glyphAtPosition as Glyphs);\n  if (glyphCurrentSide) {\n    const sideSelect = document.getElementById('side-select') as HTMLSelectElement;\n    if (sideSelect) {\n      sideSelect.value = glyphCurrentSide;\n    }\n  }\n\n  // Send command to tower to toggle the light\n  try {\n    const lightEffect = isLit ? 'on' : 'off';\n\n    // Update the glyph light tracking\n    if (isLit) {\n      glyphLightStates.add(glyphAtPosition);\n    } else {\n      glyphLightStates.delete(glyphAtPosition);\n    }\n\n    // Create a doorway light command for this specific glyph\n    const glyphLevel = GLYPHS[glyphAtPosition as keyof typeof GLYPHS].level;\n    const specificLightCommand: DoorwayLight = {\n      position: side as TowerSide,\n      level: glyphLevel as TowerLevels,\n      style: lightEffect\n    };\n\n    // If turning on, send all current lights including this one\n    // If turning off, send just this light with 'off' style to explicitly turn it off\n    if (isLit) {\n      // Get all current doorway lights and send them together\n      const allDoorwayLights = getCurrentDoorwayLights();\n      await Tower.Lights({ doorway: allDoorwayLights });\n    } else {\n      // Send explicit off command for this specific light\n      await Tower.Lights({ doorway: [specificLightCommand] });\n    }\n\n  } catch (error) {\n    logger.error('Error toggling glyph light: ' + error, '[TC]');\n\n    // Revert the visual state and glyph tracking if tower command failed\n    element.classList.toggle('glyph-lit');\n    if (isLit) {\n      glyphLightStates.delete(glyphAtPosition);\n    } else {\n      glyphLightStates.add(glyphAtPosition);\n    }\n  }\n};\n\n// Helper function to find which glyph is at a given position\nconst findGlyphAtPosition = (level: string, side: string) => {\n  const allPositions = Tower.getAllGlyphPositions();\n\n  for (const [glyph, currentSide] of Object.entries(allPositions)) {\n    if (GLYPHS[glyph as keyof typeof GLYPHS].level === level && currentSide === side) {\n      return glyph;\n    }\n  }\n\n  return null;\n};\n\n// Helper function to get glyph level\nconst getGlyphLevel = (glyph: string) => {\n  return GLYPHS[glyph as keyof typeof GLYPHS]?.level || 'middle';\n};\n\n\n// Enhanced moveGlyph function with full functionality\nconst enhancedMoveGlyph = async () => {\n  const glyphSelect = document.getElementById('glyph-select') as HTMLSelectElement;\n  const sideSelect = document.getElementById('side-select') as HTMLSelectElement;\n\n  const selectedGlyph = glyphSelect.value;\n  const targetSide = sideSelect.value;\n\n  if (!selectedGlyph || !targetSide) {\n    logger.warn('Please select a glyph and target side', '[TC]');\n    return;\n  }\n\n  try {\n    // Get current glyph position directly (more reliable than getAllGlyphPositions)\n    const currentGlyphPosition = Tower.getGlyphPosition(selectedGlyph as Glyphs);\n\n    if (!currentGlyphPosition) {\n      logger.error(`Unable to find current position for ${selectedGlyph} glyph, please perform a calibration first.`, '[TC]');\n      return;\n    }\n\n    // Get the fixed level for this glyph (glyphs can't change levels)\n    const glyphLevel = GLYPHS[selectedGlyph as keyof typeof GLYPHS].level;\n\n    // Calculate rotation needed to move glyph to target position\n    const sides = ['north', 'east', 'south', 'west'];\n    const currentSideIndex = sides.indexOf(currentGlyphPosition);\n    const targetSideIndex = sides.indexOf(targetSide);\n\n    if (currentSideIndex === -1 || targetSideIndex === -1) {\n      logger.error('Invalid current or target side', '[TC]');\n      return;\n    }\n\n    // Calculate clockwise rotation steps needed\n    let rotationSteps = (targetSideIndex - currentSideIndex + 4) % 4;\n\n    if (rotationSteps === 0) {\n      logger.info(`${selectedGlyph} glyph is already at ${targetSide} position`, '[TC]');\n      return;\n    }\n\n    // Calculate what drum position will put the selected glyph at the target side\n    let targetDrumPosition;\n    if (glyphLevel === 'top' || glyphLevel === 'middle' || glyphLevel === 'bottom') {\n      // Calculate the drum position needed to put this specific glyph at the target side\n      const currentDrumPosition = Tower.getCurrentDrumPosition(glyphLevel);\n      const sides = ['north', 'east', 'south', 'west'];\n\n      const currentDrumIndex = sides.indexOf(currentDrumPosition);\n      const currentGlyphIndex = sides.indexOf(currentGlyphPosition);\n      const targetGlyphIndex = sides.indexOf(targetSide);\n\n      // Calculate how many steps the glyph needs to move\n      let glyphSteps = (targetGlyphIndex - currentGlyphIndex + 4) % 4;\n\n      // Calculate the new drum position\n      const newDrumIndex = (currentDrumIndex + glyphSteps) % 4;\n      targetDrumPosition = sides[newDrumIndex];\n\n    }\n\n    // Set positions for all three drums\n    const topPosition = glyphLevel === 'top' ? targetDrumPosition : Tower.getCurrentDrumPosition('top');\n    const middlePosition = glyphLevel === 'middle' ? targetDrumPosition : Tower.getCurrentDrumPosition('middle');\n    const bottomPosition = glyphLevel === 'bottom' ? targetDrumPosition : Tower.getCurrentDrumPosition('bottom');\n\n    logger.info(`Moving ${selectedGlyph} glyph from ${currentGlyphPosition} to ${targetSide} by rotating ${glyphLevel} level (${rotationSteps} steps clockwise)`, '[TC]');\n\n    // Execute the rotation with all three drum positions\n    await Tower.rotateWithState(topPosition as TowerSide, middlePosition as TowerSide, bottomPosition as TowerSide);\n\n    // Restore lights after rotation\n    // Wait a moment for rotation to complete, then restore all lights and refresh UI\n    setTimeout(async () => {\n      try {\n        // Refresh glyph positions (this will also restore visual light states based on glyph tracking)\n        refreshGlyphPositions();\n\n        // Restore all lights on the physical tower based on current glyph positions\n        const allDoorwayLights = getCurrentDoorwayLights();\n        if (allDoorwayLights.length > 0) {\n          await Tower.Lights({ doorway: allDoorwayLights });\n        }\n      } catch (error) {\n        logger.error('Error restoring lights after glyph move: ' + error, '[TC]');\n      }\n    }, 1000);\n\n    logger.info(`Moved ${selectedGlyph} glyph to ${targetSide} position`, '[TC]');\n\n  } catch (error) {\n    logger.error('Error moving glyph: ' + error, '[TC]');\n  }\n};\n\n// Local volume tracking to avoid conflicts with tower state\nlet localVolume = 0;\n\n// Volume control functions\nconst volumeUp = async () => {\n  try {\n    const newVolume = Math.min(localVolume + 1, 3); // Clamp to max 3\n\n    if (newVolume === localVolume) {\n      return;\n    }\n\n    logger.info(`Setting volume from ${localVolume} to ${newVolume}`, '[TC]');\n\n    // Update local volume first\n    localVolume = newVolume;\n\n    // Get current state and update only the volume\n    const currentState = Tower.getCurrentTowerState();\n    const newState = { ...currentState };\n    newState.audio = { ...currentState.audio, volume: newVolume };\n\n    logger.debug(`Sending tower state with volume: ${newState.audio.volume}`, '[TC]');\n\n    // Send the updated state to the tower\n    await Tower.sendTowerState(newState);\n\n    // Play CardFlipPaper03 sound with new volume for feedback\n    await Tower.playSoundStateful(0x21, false, newVolume);\n\n    // Update the display\n    updateVolumeDisplay(newVolume);\n\n  } catch (error) {\n    logger.error(`Error increasing volume: ${error}`, '[TC]');\n  }\n};\n\nconst volumeDown = async () => {\n  try {\n    const newVolume = Math.max(localVolume - 1, 0); // Clamp to min 0\n\n    if (newVolume === localVolume) {\n      return;\n    }\n\n    // Update local volume first\n    localVolume = newVolume;\n\n    // Get current state and update only the volume\n    const currentState = Tower.getCurrentTowerState();\n    const newState = { ...currentState };\n    newState.audio = { ...currentState.audio, volume: newVolume };\n\n    // Send the updated state to the tower\n    await Tower.sendTowerState(newState);\n\n    // Play CardFlipPaper03 sound with new volume for feedback (except when going to Mute)\n    if (newVolume < 3) {\n      await Tower.playSoundStateful(0x21, false, newVolume);\n    }\n\n    // Update the display\n    updateVolumeDisplay(newVolume);\n\n  } catch (error) {\n    logger.error(`Error decreasing volume: ${error}`, '[TC]');\n  }\n};\n\nconst updateVolumeDisplay = (volume: number) => {\n  const volumeLevelElement = document.getElementById('volumeLevel');\n  const volumeIconElement = document.getElementById('volumeIcon');\n\n  if (volumeLevelElement) {\n    const description = VOLUME_DESCRIPTIONS[volume as keyof typeof VOLUME_DESCRIPTIONS] || 'Unknown';\n    volumeLevelElement.textContent = description;\n  }\n\n  if (volumeIconElement) {\n    const icon = VOLUME_ICONS[volume as keyof typeof VOLUME_ICONS] || '\uD83D\uDD0A';\n    volumeIconElement.textContent = icon;\n  }\n};\n\n// Initialize volume display when tower connects\nconst initializeVolumeDisplay = () => {\n  try {\n    const currentState = Tower.getCurrentTowerState();\n    localVolume = currentState.audio.volume;\n    updateVolumeDisplay(localVolume);\n  } catch (error) {\n    localVolume = 0;\n  }\n};\n\n// Expose functions globally for HTML onclick handlers\n(window as any).connectToTower = connectToTower;\n(window as any).calibrate = calibrate;\n(window as any).resetSkullCount = resetSkullCount;\n(window as any).playSound = playSound;\n(window as any).singleLight = singleLight;\n(window as any).lights = lights;\n(window as any).overrides = overrides;\n(window as any).rotate = rotate;\n(window as any).breakSeal = breakSeal;\n(window as any).clearAllLights = clearAllLights;\n(window as any).clearAllLightCheckboxes = clearAllLightCheckboxes;\n(window as any).allLightsOn = allLightsOn;\n(window as any).allLightsOff = allLightsOff;\n(window as any).randomizeLevels = randomizeLevels;\n(window as any).sealSquareClick = sealSquareClick;\n(window as any).switchTab = switchTab;\n(window as any).moveGlyph = moveGlyph;\n(window as any).toggleGlyphLight = toggleGlyphLight;\n(window as any).refreshGlyphPositions = refreshGlyphPositions;\n(window as any).filterLogs = filterLogs;\n(window as any).clearLogs = clearLogs;\n(window as any).saveState = saveState;\n(window as any).loadState = loadState;\n(window as any).resetState = resetState;\n(window as any).updateLogLevel = updateLogLevel;\n(window as any).clearLog = clearLog;\n(window as any).copyDisplayedLogs = copyDisplayedLogs;\n(window as any).downloadDisplayedLogs = downloadDisplayedLogs;\n(window as any).getGlyphsFacingDirection = getGlyphsFacingDirection;\n(window as any).sendLEDTestCommand = sendLEDTestCommand;\n(window as any).clearAllLEDs = clearAllLEDs;\n(window as any).findGlyphAtPosition = findGlyphAtPosition;\n(window as any).getGlyphLevel = getGlyphLevel;\n(window as any).glyphLightStates = glyphLightStates;\n(window as any).getCurrentDoorwayLights = getCurrentDoorwayLights;\n(window as any).updateBatteryFilter = updateBatteryFilter;\n(window as any).updateDrumDropdowns = updateDrumDropdowns;\n(window as any).refreshStatusPacket = refreshStatusPacket;\n(window as any).volumeUp = volumeUp;\n(window as any).volumeDown = volumeDown;\n(window as any).updateVolumeDisplay = updateVolumeDisplay;\n(window as any).initializeVolumeDisplay = initializeVolumeDisplay;"],
  "mappings": "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",
  "names": ["logger", "playSound", "logger", "lights", "playSound", "lights", "playSound", "rtdt_pack_state", "rtdt_unpack_state", "sides"]
}
